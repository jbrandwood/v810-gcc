diff -Naur gcc-4.9.4-pure/config.sub gcc-4.9.4/config.sub
--- gcc-4.9.4-pure/config.sub	2013-10-01 12:50:56.000000000 -0400
+++ gcc-4.9.4/config.sub	2022-02-27 14:57:28.730565500 -0500
@@ -310,7 +310,7 @@
 	| spu \
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
-	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| v810 | v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -430,7 +430,7 @@
 	| tile*-* \
 	| tron-* \
 	| ubicom32-* \
-	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| v810-* | v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
@@ -1184,10 +1184,6 @@
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
 	vaxv)
 		basic_machine=vax-dec
 		os=-sysv
diff -Naur gcc-4.9.4-pure/gcc/common/config/v810/v810-common.c gcc-4.9.4/gcc/common/config/v810/v810-common.c
--- gcc-4.9.4-pure/gcc/common/config/v810/v810-common.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/common/config/v810/v810-common.c	2022-02-27 14:57:28.740566100 -0500
@@ -0,0 +1,106 @@
+/* Common hooks for NEC V810 series.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "diagnostic-core.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "common/common-target-def.h"
+#include "opts.h"
+#include "flags.h"
+
+/* The PC-FX BIOS filesystem functions use the first 0x58 bytes of SDA. */
+#define PCFX_FSYS_SDA_RESERVED 0x58
+
+/* Information about the various small memory areas.  */
+static const int small_memory_physical_max[(int) SMALL_MEMORY_max] =
+{
+  32768,
+  65536 - PCFX_FSYS_SDA_RESERVED,
+  65536,
+};
+
+/* Set the maximum size of small memory area TYPE to the value given
+   by SIZE in structure OPTS (option text OPT passed at location LOC).  */
+
+static void
+v810_handle_memory_option (enum small_memory_type type,
+			   struct gcc_options *opts, const char *opt,
+			   int size, location_t loc)
+{
+  if (size > small_memory_physical_max[type])
+    error_at (loc, "value passed in %qs is too large", opt);
+  else
+    opts->x_small_memory_max[type] = size;
+}
+
+/* Implement TARGET_HANDLE_OPTION.  */
+
+static bool
+v810_handle_option (struct gcc_options *opts,
+		    struct gcc_options *opts_set ATTRIBUTE_UNUSED,
+		    const struct cl_decoded_option *decoded,
+		    location_t loc)
+{
+  size_t code = decoded->opt_index;
+  int value = decoded->value;
+
+  switch (code)
+    {
+    case OPT_mv810:
+      opts->x_target_flags &= ~(MASK_CPU ^ MASK_V810);
+      return true;
+
+    case OPT_msda_:
+      v810_handle_memory_option (SMALL_MEMORY_SDA, opts,
+				 decoded->orig_option_with_args_text,
+				 value, loc);
+      return true;
+
+    case OPT_mzda_:
+      v810_handle_memory_option (SMALL_MEMORY_ZDA, opts,
+				 decoded->orig_option_with_args_text,
+				 value, loc);
+      return true;
+
+    default:
+      return true;
+    }
+}
+
+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
+/* V850 enables prolog_function ... this may not help on the V810. */
+
+static const struct default_options v810_option_optimization_table[] =
+  {
+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+/* JCB    { OPT_LEVELS_1_PLUS, OPT_mprolog_function, NULL, 1 }, */
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+#undef  TARGET_DEFAULT_TARGET_FLAGS
+#define TARGET_DEFAULT_TARGET_FLAGS (MASK_DEFAULT)
+#undef  TARGET_HANDLE_OPTION
+#define TARGET_HANDLE_OPTION v810_handle_option
+#undef  TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE v810_option_optimization_table
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff -Naur gcc-4.9.4-pure/gcc/config/v810/constraints.md gcc-4.9.4/gcc/config/v810/constraints.md
--- gcc-4.9.4-pure/gcc/config/v810/constraints.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/constraints.md	2022-03-04 10:44:21.256211800 -0500
@@ -0,0 +1,93 @@
+;; Constraint definitions for V810.
+;; Copyright (C) 2011-2014 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Floating-point constraints.
+
+(define_constraint "G"
+  "A zero of some form."
+  (and (match_code "const_double")
+       (ior (match_test "GET_MODE_CLASS (mode) == MODE_FLOAT")
+	    (match_test "GET_MODE_CLASS (mode) == MODE_INT"))
+       (match_test "op == CONST0_RTX (mode)")))
+
+(define_constraint "H"
+  "@internal"
+  (and (match_code "const_double")
+       (match_test "0")))
+
+;; Integer constraints.
+
+(define_constraint "I"
+  "Integer constant 0."
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "J"
+  "A signed 5-bit immediate."
+  (and (match_code "const_int")
+       (match_test "ival >= -16 && ival <= 15")))
+
+(define_constraint "K"
+  "A signed 16-bit immediate."
+  (and (match_code "const_int")
+       (match_test "ival >= -32768 && ival <= 32767")))
+
+(define_constraint "L"
+  "A valid constant for a movhi instruction."
+  (and (match_code "const_int")
+       (ior (match_test "(ival | 0x7fff0000) == 0x7fff0000")
+	    (match_test "(ival | 0x7fff0000) + 0x10000 == 0"))))
+
+(define_constraint "M"
+  "An unsigned 16-bit immediate."
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 65535")))
+
+(define_constraint "N"
+  "An unsigned 5-bit immediate in shift instructions."
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 31")))
+
+;; No constraint "O" on the v810.
+;; No constraint "P" on the v810.
+;; No constraint "Q" on the v810.
+
+;; Extra constraints.
+
+(define_constraint "R"
+  "@internal"
+  (match_test "special_symbolref_operand (op, VOIDmode)"))
+
+(define_constraint "S"
+  "@internal"
+  (and (match_code "symbol_ref")
+       (match_test "!SYMBOL_REF_ZDA_P (op)")))
+
+;; No constraint "T" on the v810.
+
+(define_constraint "U"
+  "@internal"
+  (ior (and (match_code "symbol_ref")
+	    (match_test "SYMBOL_REF_ZDA_P (op)"))
+       (and (match_code "const")
+	    (match_test "GET_CODE (XEXP (op, 0)) == PLUS")
+	    (match_test "GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF")
+	    (match_test "SYMBOL_REF_ZDA_P (XEXP (XEXP (op, 0), 0))"))))
+
+;; No constraint "W" on the v810.
diff -Naur gcc-4.9.4-pure/gcc/config/v810/predicates.md gcc-4.9.4/gcc/config/v810/predicates.md
--- gcc-4.9.4-pure/gcc/config/v810/predicates.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/predicates.md	2022-03-04 10:44:21.211211100 -0500
@@ -0,0 +1,246 @@
+;; Predicate definitions for NEC V810.
+;; Copyright (C) 2005-2014 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Return true if OP is either a register or 0.
+
+(define_predicate "reg_or_0_operand"
+  (match_code "reg,subreg,const_int,const_double")
+{
+  if (GET_CODE (op) == CONST_INT)
+    return INTVAL (op) == 0;
+
+  else if (GET_CODE (op) == CONST_DOUBLE)
+    return satisfies_constraint_G (op);
+
+  else
+    return register_operand (op, mode);
+})
+
+;; Return true if OP is either a register or a signed five bit
+;; integer.
+
+(define_predicate "reg_or_int5_operand"
+  (match_code "reg,subreg,const_int")
+{
+  if (GET_CODE (op) == CONST_INT)
+    return CONST_OK_FOR_J (INTVAL (op));
+
+  else
+    return register_operand (op, mode);
+})
+
+;; Return true if OP is a valid call operand.
+
+(define_predicate "call_address_operand"
+  (match_code "reg,symbol_ref")
+{
+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);
+})
+
+;; Return true if OP is a valid source operand for SImode move.
+
+(define_predicate "movsi_source_operand"
+  (match_code "label_ref,symbol_ref,const_int,const_double,const,high,mem,reg,subreg")
+{
+  /* Some constants, as well as symbolic operands
+     must be done with HIGH & LO_SUM patterns.  */
+  if (CONSTANT_P (op)
+      && GET_CODE (op) != HIGH
+      && !(GET_CODE (op) == CONST_INT
+           && (CONST_OK_FOR_J (INTVAL (op))
+               || CONST_OK_FOR_K (INTVAL (op))
+               || CONST_OK_FOR_L (INTVAL (op)))))
+    return special_symbolref_operand (op, mode);
+  else
+    return general_operand (op, mode);
+})
+
+;; Return true if OP is a symbol ref with 16-bit signed value.
+
+(define_predicate "special_symbolref_operand"
+  (match_code "symbol_ref")
+{
+  if (GET_CODE (op) == CONST
+      && GET_CODE (XEXP (op, 0)) == PLUS
+      && satisfies_constraint_K (XEXP (XEXP (op, 0), 1)))
+    op = XEXP (XEXP (op, 0), 0);
+
+  if (GET_CODE (op) == SYMBOL_REF)
+    return (SYMBOL_REF_FLAGS (op)
+        & (SYMBOL_FLAG_ZDA | SYMBOL_FLAG_TDA | SYMBOL_FLAG_SDA)) != 0;
+
+  return FALSE;
+})
+
+;; Return nonzero if the given RTX is suitable for collapsing into a
+;; jump to a function prologue.
+;;
+;; N.B. Heavily modified from V850 for new V810 stack frame, and frame pointer.
+
+(define_predicate "pattern_is_ok_for_prologue"
+  (match_code "parallel")
+{
+  int count = XVECLEN (op, 0);
+  int i;
+  rtx vector_element;
+
+  /* If there are no registers to save then the function prologue
+     is not suitable.  */
+  if (count <= 3)
+    return 0;
+
+  /* The pattern matching has already established that we are adjusting the
+     stack and pushing at least one register.  We must now check that the
+     remaining entries in the vector to make sure that they are also register
+     pushes, except for the last entry which should be a CLOBBER of r10.
+
+     The test below performs the C equivalent of this machine description
+     pattern match:
+
+     (set (mem:SI (plus:SI (reg:SI 2)
+      (match_operand:SI 2 "immediate_operand" "i")))
+      (match_operand:SI 3 "register_is_ok_for_epilogue" "r"))
+
+     */
+
+  for (i = 2; i < count - 1; i++)
+    {
+      rtx dest;
+      rtx src;
+      rtx plus;
+
+      vector_element = XVECEXP (op, 0, i);
+
+      if (GET_CODE (vector_element) != SET)
+    return 0;
+
+      dest = SET_DEST (vector_element);
+      src = SET_SRC (vector_element);
+
+      if (GET_CODE (dest) != MEM
+      || GET_MODE (dest) != SImode
+      || GET_CODE (src) != REG
+      || GET_MODE (src) != SImode
+      || ! register_is_ok_for_epilogue (src, SImode))
+    return 0;
+
+      plus = XEXP (dest, 0);
+
+      if ( GET_CODE (plus) != PLUS
+      || GET_CODE (XEXP (plus, 0)) != REG
+      || GET_MODE (XEXP (plus, 0)) != SImode
+      || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM
+      || GET_CODE (XEXP (plus, 1)) != CONST_INT)
+    return 0;
+    }
+
+  /* Make sure that the last entry in the vector is a clobber.  */
+  vector_element = XVECEXP (op, 0, i++);
+
+  if (GET_CODE (vector_element) != CLOBBER
+      || GET_CODE (XEXP (vector_element, 0)) != REG
+      || REGNO (XEXP (vector_element, 0)) != 1)
+    return 0;
+
+  return i == count;
+})
+
+;; Return nonzero if the given RTX is suitable for collapsing into
+;; jump to a function epilogue.
+;;
+;; N.B. Heavily modified from V850 for new V810 stack frame, and frame pointer.
+
+(define_predicate "pattern_is_ok_for_epilogue"
+  (match_code "parallel")
+{
+  int count = XVECLEN (op, 0);
+  int i;
+  rtx vector_element;
+
+  /* If there are no registers to restore then the function epilogue
+     is not suitable.  */
+  if (count <= 3)
+    return 0;
+
+  /* The pattern matching has already established that we are performing a
+     function epilogue and that we are popping at least one register.  We must
+     now check the remaining entries in the vector to make sure that they are
+     also register pops.  There is no good reason why there should ever be
+     anything else in this vector, but being paranoid always helps...
+
+     The test below performs the C equivalent of this machine description
+     pattern match:
+
+        (set (match_operand:SI n "register_is_ok_for_epilogue" "r")
+      (mem:SI (plus:SI (reg:SI 2) (match_operand:SI n "immediate_operand" "i"))))
+     */
+
+  for (i = 2; i < count - 1; i++)
+    {
+      rtx dest;
+      rtx src;
+      rtx plus;
+
+      vector_element = XVECEXP (op, 0, i);
+
+      if (GET_CODE (vector_element) != SET)
+    return 0;
+
+      dest = SET_DEST (vector_element);
+      src = SET_SRC (vector_element);
+
+      if (GET_CODE (dest) != REG
+      || GET_MODE (dest) != SImode
+      || ! register_is_ok_for_epilogue (dest, SImode)
+      || GET_CODE (src) != MEM
+      || GET_MODE (src) != SImode)
+    return 0;
+
+      plus = XEXP (src, 0);
+
+      if (GET_CODE (plus) != PLUS
+      || GET_CODE (XEXP (plus, 0)) != REG
+      || GET_MODE (XEXP (plus, 0)) != SImode
+      || REGNO (XEXP (plus, 0)) != FRAME_POINTER_REGNUM
+      || GET_CODE (XEXP (plus, 1)) != CONST_INT)
+    return 0;
+    }
+
+  /* Make sure that the last entry in the vector is a clobber.  */
+  vector_element = XVECEXP (op, 0, i++);
+
+  if (GET_CODE (vector_element) != CLOBBER
+      || GET_CODE (XEXP (vector_element, 0)) != REG
+      || REGNO (XEXP (vector_element, 0)) != 1)
+    return 0;
+
+  return 1;
+})
+
+;; Return true if the given RTX is a register which can be restored by
+;; a function epilogue.
+
+(define_predicate "register_is_ok_for_epilogue"
+  (match_code "reg")
+{
+  /* The save/restore routines can only cope with registers 1, 2, 20 - 31.  */
+  return ((GET_CODE (op) == REG)
+          && ((REGNO (op) == 1) || (REGNO (op) == 2)
+              || (REGNO (op) >= 20 && REGNO (op) <= 31)));
+})
diff -Naur gcc-4.9.4-pure/gcc/config/v810/rtems.h gcc-4.9.4/gcc/config/v810/rtems.h
--- gcc-4.9.4-pure/gcc/config/v810/rtems.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/rtems.h	2022-02-27 14:57:28.764567500 -0500
@@ -0,0 +1,30 @@
+/* Definitions for rtems targeting a v810 using ELF.
+   Copyright (C) 2012-2014 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Specify predefined symbols in preprocessor.  */
+
+#define TARGET_OS_CPP_BUILTINS() do {		\
+  builtin_define( "__rtems__" );		\
+  builtin_assert( "system=rtems" );		\
+} while (0)
diff -Naur gcc-4.9.4-pure/gcc/config/v810/t-rtems gcc-4.9.4/gcc/config/v810/t-rtems
--- gcc-4.9.4-pure/gcc/config/v810/t-rtems	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/t-rtems	2022-02-27 14:57:28.776568100 -0500
@@ -0,0 +1,4 @@
+# Custom multilibs for RTEMS
+
+MULTILIB_OPTIONS  = mv810
+MULTILIB_DIRNAMES = v810
diff -Naur gcc-4.9.4-pure/gcc/config/v810/t-v810 gcc-4.9.4/gcc/config/v810/t-v810
--- gcc-4.9.4-pure/gcc/config/v810/t-v810	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/t-v810	2022-02-27 14:57:28.779568300 -0500
@@ -0,0 +1,32 @@
+# Copyright (C) 1997-2014 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# TCFLAGS = -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow -fsingle-precision-constant -Wdouble-promotion -fno-omit-frame-pointer
+
+TCFLAGS = -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow -fsingle-precision-constant -Wdouble-promotion
+
+TARGET_LIBGCC2_CFLAGS = -msda=256 -mzda=0 -O2 -mno-prolog-function
+
+v810-c.o: $(srcdir)/config/v810/v810-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(CPPLIB_H) $(TREE_H) $(C_PRAGMA_H) $(GGC_H) $(TM_P_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/v810/v810-c.c 
+
+# Local Variables:
+# mode: Makefile
+# End:
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810-c.c gcc-4.9.4/gcc/config/v810/v810-c.c
--- gcc-4.9.4-pure/gcc/config/v810/v810-c.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810-c.c	2022-02-27 14:57:28.785568700 -0500
@@ -0,0 +1,274 @@
+/* v810 specific, C compiler specific functions.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Contributed by Jeff Law (law@cygnus.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "cpplib.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "c-family/c-pragma.h"
+#include "diagnostic-core.h"
+#include "ggc.h"
+#include "tm_p.h"
+
+#ifndef streq
+#define streq(a,b) (strcmp (a, b) == 0)
+#endif
+
+static int  pop_data_area          (v810_data_area);
+static int  push_data_area         (v810_data_area);
+static void mark_current_function_as_interrupt (void);
+
+/* Push a data area onto the stack.  */
+
+static int
+push_data_area (v810_data_area data_area)
+{
+  data_area_stack_element * elem;
+
+  elem = (data_area_stack_element *) xmalloc (sizeof (* elem));
+
+  if (elem == NULL)
+    return 0;
+
+  elem->prev      = data_area_stack;
+  elem->data_area = data_area;
+
+  data_area_stack = elem;
+
+  return 1;
+}
+
+/* Remove a data area from the stack.  */
+
+static int
+pop_data_area (v810_data_area data_area)
+{
+  if (data_area_stack == NULL)
+    warning (OPT_Wpragmas, "#pragma GHS endXXXX found without "
+	     "previous startXXX");
+  else if (data_area != data_area_stack->data_area)
+    warning (OPT_Wpragmas, "#pragma GHS endXXX does not match "
+	     "previous startXXX");
+  else
+    {
+      data_area_stack_element * elem;
+
+      elem = data_area_stack;
+      data_area_stack = data_area_stack->prev;
+
+      free (elem);
+
+      return 1;
+    }
+
+  return 0;
+}
+
+/* Set the machine specific 'interrupt' attribute on the current function.  */
+
+static void
+mark_current_function_as_interrupt (void)
+{
+  tree name;
+  
+  if (current_function_decl ==  NULL_TREE)
+    {
+      warning (0, "cannot set interrupt attribute: no current function");
+      return;
+    }
+
+  name = get_identifier ("interrupt");
+
+  if (name == NULL_TREE || TREE_CODE (name) != IDENTIFIER_NODE)
+    {
+      warning (0, "cannot set interrupt attribute: no such identifier");
+      return;
+    }
+  
+  decl_attributes (&current_function_decl,
+		   tree_cons (name, NULL_TREE, NULL_TREE), 0);
+}
+
+
+/* Support for GHS pragmata.  */
+
+void
+ghs_pragma_section (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  int repeat = 0;
+
+  /* #pragma ghs section [name = alias [, name = alias [, ...]]] */
+  do
+    {
+      tree x;
+      enum cpp_ttype type;
+      tree sect_ident;
+      const char *sect, *alias;
+      enum GHS_section_kind kind;
+      
+      type = pragma_lex (&x);
+      
+      if (type == CPP_EOF && !repeat)
+	goto reset;
+      else if (type == CPP_NAME)
+	{
+	  sect_ident = x;
+	  sect = IDENTIFIER_POINTER (sect_ident);
+	}
+      else
+	goto bad;
+      repeat = 0;
+      
+      if (pragma_lex (&x) != CPP_EQ)
+	goto bad;
+      if (pragma_lex (&x) != CPP_NAME)
+	goto bad;
+      
+      alias = IDENTIFIER_POINTER (x);
+      
+      type = pragma_lex (&x);
+      if (type == CPP_COMMA)
+	repeat = 1;
+      else if (type != CPP_EOF)
+	warning (OPT_Wpragmas, "junk at end of #pragma ghs section");
+      
+      if      (streq (sect, "data"))    kind = GHS_SECTION_KIND_DATA;
+      else if (streq (sect, "text"))    kind = GHS_SECTION_KIND_TEXT;
+      else if (streq (sect, "rodata"))  kind = GHS_SECTION_KIND_RODATA;
+      else if (streq (sect, "const"))   kind = GHS_SECTION_KIND_RODATA;
+      else if (streq (sect, "rosdata")) kind = GHS_SECTION_KIND_ROSDATA;
+      else if (streq (sect, "rozdata")) kind = GHS_SECTION_KIND_ROZDATA;
+      else if (streq (sect, "sdata"))   kind = GHS_SECTION_KIND_SDATA;
+      else if (streq (sect, "tdata"))   kind = GHS_SECTION_KIND_TDATA;
+      else if (streq (sect, "zdata"))   kind = GHS_SECTION_KIND_ZDATA;
+      /* According to GHS beta documentation, the following should not be
+	 allowed!  */
+      else if (streq (sect, "bss"))     kind = GHS_SECTION_KIND_BSS;
+      else if (streq (sect, "zbss"))    kind = GHS_SECTION_KIND_ZDATA;
+      else
+	{
+	  warning (0, "unrecognized section name %qE", sect_ident);
+	  return;
+	}
+      
+      if (streq (alias, "default"))
+	GHS_current_section_names [kind] = NULL;
+      else
+	GHS_current_section_names [kind] =
+	  build_string (strlen (alias) + 1, alias);
+    }
+  while (repeat);
+
+  return;
+
+ bad:
+  warning (OPT_Wpragmas, "malformed #pragma ghs section");
+  return;
+
+ reset:
+  /* #pragma ghs section \n: Reset all section names back to their defaults.  */
+  {
+    int i;
+    
+    for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)
+      GHS_current_section_names [i] = NULL;
+  }
+}
+
+void
+ghs_pragma_interrupt (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs interrupt");
+  
+  mark_current_function_as_interrupt ();
+}
+
+void
+ghs_pragma_starttda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs starttda");
+  
+  push_data_area (DATA_AREA_TDA);
+}
+
+void
+ghs_pragma_startsda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs startsda");
+  
+  push_data_area (DATA_AREA_SDA);
+}
+
+void
+ghs_pragma_startzda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs startzda");
+  
+  push_data_area (DATA_AREA_ZDA);
+}
+
+void
+ghs_pragma_endtda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs endtda");
+  
+  pop_data_area (DATA_AREA_TDA);
+}
+
+void
+ghs_pragma_endsda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs endsda");
+  
+  pop_data_area (DATA_AREA_SDA);
+}
+
+void
+ghs_pragma_endzda (cpp_reader * pfile ATTRIBUTE_UNUSED)
+{
+  tree x;
+  
+  if (pragma_lex (&x) != CPP_EOF)
+    warning (OPT_Wpragmas, "junk at end of #pragma ghs endzda");
+  
+  pop_data_area (DATA_AREA_ZDA);
+}
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810-modes.def gcc-4.9.4/gcc/config/v810/v810-modes.def
--- gcc-4.9.4-pure/gcc/config/v810/v810-modes.def	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810-modes.def	2022-02-27 14:57:28.791569000 -0500
@@ -0,0 +1,19 @@
+/* Definitions of target machine for GNU compiler. NEC V810 series
+   Copyright (C) 2005-2014 Free Software Foundation, Inc.
+   Contributed by NEC EL
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810-opts.h gcc-4.9.4/gcc/config/v810/v810-opts.h
--- gcc-4.9.4-pure/gcc/config/v810/v810-opts.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810-opts.h	2022-02-27 14:57:28.798569400 -0500
@@ -0,0 +1,38 @@
+/* Definitions for option handling for NEC V810 series.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef V810_OPTS_H
+#define V810_OPTS_H
+
+enum small_memory_type {
+  /* thread data area, using tp (r5) as base register */
+  SMALL_MEMORY_TDA = 0,
+  /* small data area using gp (r4) as base register */
+  SMALL_MEMORY_SDA,
+  /* zero data area using r0 as base register */
+  SMALL_MEMORY_ZDA,
+  SMALL_MEMORY_max
+};
+
+#endif
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810-protos.h gcc-4.9.4/gcc/config/v810/v810-protos.h
--- gcc-4.9.4-pure/gcc/config/v810/v810-protos.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810-protos.h	2022-03-07 16:20:19.705840400 -0500
@@ -0,0 +1,65 @@
+/* Prototypes for v810.c functions used in the md file & elsewhere.
+   Copyright (C) 1999-2014 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Function prototypes that cannot exist in v810.h due to dependency
+   complications.  */
+#ifndef GCC_V810_PROTOS_H
+#define GCC_V810_PROTOS_H
+
+extern void   expand_prologue               (void);
+extern void   expand_epilogue               (void);
+extern int    v810_handle_pragma            (int (*)(void), void (*)(int), char *);
+extern int    compute_register_save_size    (long *);
+extern int    compute_frame_size            (int, long *);
+extern void   v810_init_expanders           (void);
+
+#ifdef RTX_CODE
+// JCB 2022 - Tried removing it, still need it unless we change v810.h
+extern HOST_WIDE_INT v810_initial_elimination_offset (int, int);
+
+extern rtx    v810_return_addr              (int);
+extern const char *output_move_single       (rtx *);
+extern void   notice_update_cc              (rtx, rtx);
+extern char * construct_save_jal            (rtx);
+extern char * construct_restore_jr          (rtx);
+
+#ifdef HAVE_MACHINE_MODES
+// JCB 2018
+// extern enum machine_mode  v810_select_cc_mode (RTX_CODE, rtx, rtx);
+#endif
+#endif /* RTX_CODE */
+
+#ifdef TREE_CODE
+extern int    v810_interrupt_function_p     (tree);
+extern void   v810_output_aligned_bss       (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int);
+extern void   v810_output_common            (FILE *, tree, const char *, int, int);
+extern void   v810_output_local             (FILE *, tree, const char *, int, int);
+extern v810_data_area v810_get_data_area    (tree);
+#endif
+
+extern void ghs_pragma_section		    (struct cpp_reader *);
+extern void ghs_pragma_interrupt	    (struct cpp_reader *);
+extern void ghs_pragma_starttda		    (struct cpp_reader *);
+extern void ghs_pragma_startsda		    (struct cpp_reader *);
+extern void ghs_pragma_startzda		    (struct cpp_reader *);
+extern void ghs_pragma_endtda		    (struct cpp_reader *);
+extern void ghs_pragma_endsda		    (struct cpp_reader *);
+extern void ghs_pragma_endzda		    (struct cpp_reader *);
+
+#endif /* ! GCC_V810_PROTOS_H */
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810.c gcc-4.9.4/gcc/config/v810/v810.c
--- gcc-4.9.4-pure/gcc/config/v810/v810.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810.c	2022-03-07 17:11:16.856794200 -0500
@@ -0,0 +1,2379 @@
+/* Subroutines for insn-output.c for NEC V810 series
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   Contributed by Jeff Law (law@cygnus.com).
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "stor-layout.h"
+#include "varasm.h"
+#include "calls.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "expr.h"
+#include "function.h"
+#include "diagnostic-core.h"
+#include "ggc.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "df.h"
+#include "opts.h"
+
+/* Remove the warning about the unused value in CC_STATUS_INIT */
+#pragma GCC diagnostic ignored "-Wunused-value"
+
+#ifndef streq
+#define streq(a,b) (strcmp (a, b) == 0)
+#endif
+
+static void v810_print_operand_address (FILE *, rtx);
+
+/* Names of the various data areas used on the v810.  */
+tree GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];
+tree GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];
+
+/* Track the current data area set by the data area pragma (which 
+   can be nested).  Tested by check_default_data_area.  */
+data_area_stack_element * data_area_stack = NULL;
+
+/* True if we don't need to check any more if the current
+   function is an interrupt handler.  */
+static int v810_interrupt_cache_p = FALSE;
+
+rtx v810_compare_op0, v810_compare_op1;
+
+/* Whether current function is an interrupt handler.  */
+static int v810_interrupt_p = FALSE;
+
+static GTY(()) section * rosdata_section;
+static GTY(()) section * rozdata_section;
+static GTY(()) section * tdata_section;
+static GTY(()) section * zdata_section;
+static GTY(()) section * zbss_section;
+
+#if 0
+// JCB 2022 - Seems to be specific to DWARF2
+/* We use this to wrap all emitted insns in the prologue.  */
+static rtx
+F (rtx x)
+{
+  if (GET_CODE (x) != CLOBBER)
+    RTX_FRAME_RELATED_P (x) = 1;
+  return x;
+}
+
+/* Mark all the subexpressions of the PARALLEL rtx PAR as
+   frame-related.  Return PAR.
+
+   dwarf2out.c:dwarf2out_frame_debug_expr ignores sub-expressions of a
+   PARALLEL rtx other than the first if they do not have the
+   FRAME_RELATED flag set on them.  */
+
+static rtx
+v850_all_frame_related (rtx par)
+{
+  int len = XVECLEN (par, 0);
+  int i;
+
+  gcc_assert (GET_CODE (par) == PARALLEL);
+  for (i = 0; i < len; i++)
+    F (XVECEXP (par, 0, i));
+
+  return par;
+}
+#endif
+
+/* Handle the TARGET_PASS_BY_REFERENCE target hook.
+   Specify whether to pass the argument by reference.  */
+
+static bool
+v810_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,
+                        enum machine_mode mode, const_tree type,
+                        bool named ATTRIBUTE_UNUSED)
+{
+  unsigned HOST_WIDE_INT size;
+
+  if (type)
+    size = int_size_in_bytes (type);
+  else
+    size = GET_MODE_SIZE (mode);
+
+  return size > 8;
+}
+
+/* Return an RTX to represent where an argument with mode MODE
+   and type TYPE will be passed to a function.  If the result
+   is NULL_RTX, the argument will be pushed.  */
+
+static rtx
+v810_function_arg (cumulative_args_t cum_v, enum machine_mode mode,
+                   const_tree type, bool named)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  rtx result = NULL_RTX;
+  int size, align;
+
+  if (!named)
+    return NULL_RTX;
+
+  if (mode == BLKmode)
+    size = int_size_in_bytes (type);
+  else
+    size = GET_MODE_SIZE (mode);
+
+  size = (size + UNITS_PER_WORD -1) & ~(UNITS_PER_WORD -1);
+
+  if (size < 1)
+    {
+      /* Once we have stopped using argument registers, do not start up again.  */
+      cum->nbytes = 4 * UNITS_PER_WORD;
+      return NULL_RTX;
+    }
+
+  if (size <= UNITS_PER_WORD && type)
+    align = TYPE_ALIGN (type) / BITS_PER_UNIT;
+  else
+    align = size;
+
+  cum->nbytes = (cum->nbytes + align - 1) &~(align - 1);
+
+  if (cum->nbytes > 4 * UNITS_PER_WORD)
+    return NULL_RTX;
+
+  if (type == NULL_TREE
+      && cum->nbytes + size > 4 * UNITS_PER_WORD)
+    return NULL_RTX;
+
+  switch (cum->nbytes / UNITS_PER_WORD)
+    {
+    case 0:
+      result = gen_rtx_REG (mode, 6);
+      break;
+    case 1:
+      result = gen_rtx_REG (mode, 7);
+      break;
+    case 2:
+      result = gen_rtx_REG (mode, 8);
+      break;
+    case 3:
+      result = gen_rtx_REG (mode, 9);
+      break;
+    default:
+      result = NULL_RTX;
+    }
+
+  return result;
+}
+
+/* Return the number of bytes which must be put into registers
+   for values which are part in registers and part in memory.  */
+static int
+v810_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,
+                        tree type, bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  int size, align;
+
+  if (mode == BLKmode)
+    size = int_size_in_bytes (type);
+  else
+    size = GET_MODE_SIZE (mode);
+
+  if (size < 1)
+    size = 1;
+  
+  if (type)
+    align = TYPE_ALIGN (type) / BITS_PER_UNIT;
+  else
+    align = size;
+
+  cum->nbytes = (cum->nbytes + align - 1) & ~ (align - 1);
+
+  if (cum->nbytes > 4 * UNITS_PER_WORD)
+    return 0;
+
+  if (cum->nbytes + size <= 4 * UNITS_PER_WORD)
+    return 0;
+
+  if (type == NULL_TREE
+      && cum->nbytes + size > 4 * UNITS_PER_WORD)
+    return 0;
+
+  return 4 * UNITS_PER_WORD - cum->nbytes;
+}
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+
+static void
+v810_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,
+                           const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  cum->nbytes += (((type && int_size_in_bytes (type) > 8
+                    ? GET_MODE_SIZE (Pmode)
+                    : (mode != BLKmode
+                       ? GET_MODE_SIZE (mode)
+                       : int_size_in_bytes (type))) + UNITS_PER_WORD - 1)
+                  & -UNITS_PER_WORD);
+}
+
+/* Return the high and low words of a CONST_DOUBLE */
+
+static void
+const_double_split (rtx x, HOST_WIDE_INT * p_high, HOST_WIDE_INT * p_low)
+{
+  if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      long t[2];
+      REAL_VALUE_TYPE rv;
+
+      switch (GET_MODE (x))
+        {
+        case DFmode:
+          REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+          REAL_VALUE_TO_TARGET_DOUBLE (rv, t);
+          *p_high = t[1];       /* since v810 is little endian */
+          *p_low = t[0];        /* high is second word */
+          return;
+
+        case SFmode:
+          REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+          REAL_VALUE_TO_TARGET_SINGLE (rv, *p_high);
+          *p_low = 0;
+          return;
+
+        case VOIDmode:
+        case DImode:
+          *p_high = CONST_DOUBLE_HIGH (x);
+          *p_low  = CONST_DOUBLE_LOW (x);
+          return;
+
+        default:
+          break;
+        }
+    }
+
+  fatal_insn ("const_double_split got a bad insn:", x);
+}
+
+
+/* Return the cost of the rtx R with code CODE.  */
+
+static int
+const_costs_int (HOST_WIDE_INT value, int zero_cost)
+{
+  if (CONST_OK_FOR_I (value))
+      return zero_cost;
+  else if (CONST_OK_FOR_J (value))
+    return 1;
+  else if (CONST_OK_FOR_K (value))
+    return 2;
+  else
+    return 4;
+}
+
+static int
+const_costs (rtx r, enum rtx_code c)
+{
+  HOST_WIDE_INT high, low;
+
+  switch (c)
+    {
+    case CONST_INT:
+      return const_costs_int (INTVAL (r), 0);
+
+    case CONST_DOUBLE:
+      const_double_split (r, &high, &low);
+      if (GET_MODE (r) == SFmode)
+        return const_costs_int (high, 1);
+      else
+        return const_costs_int (high, 1) + const_costs_int (low, 1);
+
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+      return 2;
+
+    case HIGH:
+      return 1;
+
+    default:
+      return 4;
+    }
+}
+
+static bool
+v810_rtx_costs (rtx x,
+                int codearg,
+                int outer_code ATTRIBUTE_UNUSED,
+                int opno ATTRIBUTE_UNUSED,
+                int * total, bool speed ATTRIBUTE_UNUSED)
+{
+  enum rtx_code code = (enum rtx_code) codearg;
+
+  switch (code)
+    {
+    case CONST_INT:
+    case CONST_DOUBLE:
+    case CONST:
+    case SYMBOL_REF:
+    case LABEL_REF:
+      *total = COSTS_N_INSNS (const_costs (x, code));
+      return true;
+
+    case MOD:
+    case DIV:
+    case UMOD:
+    case UDIV:
+        *total = 60;
+      return true;
+
+    case MULT:
+        *total = 20;
+      return true;
+
+    case ZERO_EXTRACT:
+      if (outer_code == COMPARE)
+        *total = 0;
+      return false;
+
+    default:
+      return false;
+    }
+}
+
+/* Print operand X using operand code CODE to assembly language output file
+   FILE.  */
+
+static void
+v810_print_operand (FILE * file, rtx x, int code)
+{
+  HOST_WIDE_INT high, low;
+
+  switch (code)
+    {
+    case 'c':
+      /* We use 'c' operands with symbols for .vtinherit.  */
+      if (GET_CODE (x) == SYMBOL_REF)
+        {
+          output_addr_const(file, x);
+          break;
+        }
+      /* Fall through.  */
+    case 'b':
+    case 'B':
+    case 'C':
+      switch ((code == 'B' || code == 'C')
+              ? reverse_condition (GET_CODE (x)) : GET_CODE (x))
+        {
+          case NE:
+            if (code == 'c' || code == 'C')
+              fprintf (file, "nz");
+            else
+              fprintf (file, "ne");
+            break;
+          case EQ:
+            if (code == 'c' || code == 'C')
+              fprintf (file, "z");
+            else
+              fprintf (file, "e");
+            break;
+          case GE:
+            fprintf (file, "ge");
+            break;
+          case GT:
+            fprintf (file, "gt");
+            break;
+          case LE:
+            fprintf (file, "le");
+            break;
+          case LT:
+            fprintf (file, "lt");
+            break;
+          case GEU:
+            fprintf (file, "nl");
+            break;
+          case GTU:
+            fprintf (file, "h");
+            break;
+          case LEU:
+            fprintf (file, "nh");
+            break;
+          case LTU:
+            fprintf (file, "l");
+            break;
+          default:
+            gcc_unreachable ();
+        }
+      break;
+    case 'F':                   /* High word of CONST_DOUBLE.  */
+      switch (GET_CODE (x))
+        {
+        case CONST_INT:
+          fprintf (file, "%d", (INTVAL (x) >= 0) ? 0 : -1);
+          break;
+          
+        case CONST_DOUBLE:
+          const_double_split (x, &high, &low);
+          fprintf (file, "%ld", (long) high);
+          break;
+
+        default:
+          gcc_unreachable ();
+        }
+      break;
+    case 'G':                   /* Low word of CONST_DOUBLE.  */
+      switch (GET_CODE (x))
+        {
+        case CONST_INT:
+          fprintf (file, "%ld", (long) INTVAL (x));
+          break;
+          
+        case CONST_DOUBLE:
+          const_double_split (x, &high, &low);
+          fprintf (file, "%ld", (long) low);
+          break;
+
+        default:
+          gcc_unreachable ();
+        }
+      break;
+    case 'L':
+      fprintf (file, "%d\n", (int)(INTVAL (x) & 0xffff));
+      break;
+    case 'M':
+      fprintf (file, "%d", exact_log2 (INTVAL (x)));
+      break;
+    case 'O':
+      gcc_assert (special_symbolref_operand (x, VOIDmode));
+      
+      if (GET_CODE (x) == CONST)
+        x = XEXP (XEXP (x, 0), 0);
+      else
+        gcc_assert (GET_CODE (x) == SYMBOL_REF);
+      
+      if (SYMBOL_REF_ZDA_P (x))
+        fprintf (file, "zdaoff");
+      else if (SYMBOL_REF_SDA_P (x))
+        fprintf (file, "sdaoff");
+      else if (SYMBOL_REF_TDA_P (x))
+        fprintf (file, "tdaoff");
+      else
+        gcc_unreachable ();
+      break;
+    case 'P':
+      gcc_assert (special_symbolref_operand (x, VOIDmode));
+      output_addr_const (file, x);
+      break;
+    case 'Q':
+      gcc_assert (special_symbolref_operand (x, VOIDmode));
+      
+      if (GET_CODE (x) == CONST)
+        x = XEXP (XEXP (x, 0), 0);
+      else
+        gcc_assert (GET_CODE (x) == SYMBOL_REF);
+      
+      if (SYMBOL_REF_ZDA_P (x))
+        fprintf (file, "r0");
+      else if (SYMBOL_REF_SDA_P (x))
+        fprintf (file, "gp");
+      else if (SYMBOL_REF_TDA_P (x))
+        fprintf (file, "tp");
+      else
+        gcc_unreachable ();
+      break;
+    case 'R':           /* 2nd word of a double.  */
+      switch (GET_CODE (x))
+        {
+        case REG:
+          fprintf (file, reg_names[REGNO (x) + 1]);
+          break;
+        case MEM:
+          x = XEXP (adjust_address (x, SImode, 4), 0);
+          v810_print_operand_address (file, x);
+          if (GET_CODE (x) == CONST_INT)
+            fprintf (file, "[r0]");
+          break;
+          
+	case CONST_INT:
+	  {
+	    unsigned HOST_WIDE_INT v = INTVAL (x);
+
+	    /* Trickery to avoid problems with shifting
+	       32-bits at a time on a 32-bit host.  */
+	    v = v >> 16;
+	    v = v >> 16;	  
+	    fprintf (file, HOST_WIDE_INT_PRINT_HEX, v);
+	    break;
+	  }
+
+	case CONST_DOUBLE:
+	  fprintf (file, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_HIGH (x));
+	  break;
+
+	default:
+	  debug_rtx (x);
+	  gcc_unreachable ();
+        }
+      break;
+    case 'S':
+      {
+        /* Nothing to do on the V810. (TDA references use st/ld with r5.) */
+        break;
+      }
+    case 'T':
+      {
+        /* Nothing to do on the V810. (TDA references use st/ld with r5.) */
+        break;
+      }
+    case 'W':                   /* Print the instruction suffix.  */
+      switch (GET_MODE (x))
+        {
+        default:
+          gcc_unreachable ();
+
+        case QImode: fputs (".b", file); break;
+        case HImode: fputs (".h", file); break;
+        case SImode: fputs (".w", file); break;
+        case SFmode: fputs (".w", file); break;
+        }
+      break;
+    case '.':                   /* Register r0.  */
+      fputs (reg_names[0], file);
+      break;
+    case 'z':                   /* Reg or zero.  */
+      if (REG_P (x))
+	fputs (reg_names[REGNO (x)], file);
+      else if ((GET_MODE(x) == SImode
+		|| GET_MODE(x) == DFmode
+		|| GET_MODE(x) == SFmode)
+		&& x == CONST0_RTX(GET_MODE(x)))
+      fputs (reg_names[0], file);
+      else
+        {
+          gcc_assert (x == const0_rtx);
+          fputs (reg_names[0], file);
+        }
+      break;
+    default:
+      switch (GET_CODE (x))
+        {
+        case MEM:
+          if (GET_CODE (XEXP (x, 0)) == CONST_INT)
+            output_address (gen_rtx_PLUS (SImode, gen_rtx_REG (SImode, 0),
+                                          XEXP (x, 0)));
+          else
+            output_address (XEXP (x, 0));
+          break;
+
+        case REG:
+          fputs (reg_names[REGNO (x)], file);
+          break;
+        case SUBREG:
+          fputs (reg_names[subreg_regno (x)], file);
+          break;
+	case CONST_DOUBLE:
+	  fprintf (file, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));
+	  break;
+
+        case CONST_INT:
+        case SYMBOL_REF:
+        case CONST:
+        case LABEL_REF:
+        case CODE_LABEL:
+          v810_print_operand_address (file, x);
+          break;
+        default:
+          gcc_unreachable ();
+        }
+      break;
+
+    }
+}
+
+
+/* Output assembly language output for the address ADDR to FILE.  */
+
+static void
+v810_print_operand_address (FILE * file, rtx addr)
+{
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      fprintf (file, "0[");
+      v810_print_operand (file, addr, 0);
+      fprintf (file, "]");
+      break;
+    case LO_SUM:
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+        {
+          /* reg,foo */
+          fprintf (file, "lo(");
+          v810_print_operand (file, XEXP (addr, 1), 0);
+          fprintf (file, ")[");
+          v810_print_operand (file, XEXP (addr, 0), 0);
+          fprintf (file, "]");
+        }
+      break;
+    case PLUS:
+      if (GET_CODE (XEXP (addr, 0)) == REG
+          || GET_CODE (XEXP (addr, 0)) == SUBREG)
+        {
+          /* reg,foo */
+          v810_print_operand (file, XEXP (addr, 1), 0);
+          fprintf (file, "[");
+          v810_print_operand (file, XEXP (addr, 0), 0);
+          fprintf (file, "]");
+        }
+      else
+        {
+          v810_print_operand (file, XEXP (addr, 0), 0);
+          fprintf (file, "+");
+          v810_print_operand (file, XEXP (addr, 1), 0);
+        }
+      break;
+    case SYMBOL_REF:
+      {
+        const char *off_name = NULL;
+        const char *reg_name = NULL;
+
+        if (SYMBOL_REF_ZDA_P (addr))
+          {
+            off_name = "zdaoff";
+            reg_name = "r0";
+          }
+        else if (SYMBOL_REF_SDA_P (addr))
+          {
+            off_name = "sdaoff";
+            reg_name = "gp";
+          }
+        else if (SYMBOL_REF_TDA_P (addr))
+          {
+            off_name = "tdaoff";
+            reg_name = "tp";
+          }
+
+        if (off_name)
+          fprintf (file, "%s(", off_name);
+        output_addr_const (file, addr);
+        if (reg_name)
+          fprintf (file, ")[%s]", reg_name);
+      }
+      break;
+    case CONST:
+      if (special_symbolref_operand (addr, VOIDmode))
+        {
+          rtx x = XEXP (XEXP (addr, 0), 0);
+          const char *off_name;
+          const char *reg_name;
+
+          if (SYMBOL_REF_ZDA_P (x))
+            {
+              off_name = "zdaoff";
+              reg_name = "r0";
+            }
+          else if (SYMBOL_REF_SDA_P (x))
+            {
+              off_name = "sdaoff";
+              reg_name = "gp";
+            }
+          else if (SYMBOL_REF_TDA_P (x))
+            {
+              off_name = "tdaoff";
+              reg_name = "tp";
+            }
+          else
+            gcc_unreachable ();
+
+          fprintf (file, "%s(", off_name);
+          output_addr_const (file, addr);
+          fprintf (file, ")[%s]", reg_name);
+        }
+      else
+        output_addr_const (file, addr);
+      break;
+    default:
+      output_addr_const (file, addr);
+      break;
+    }
+}
+
+static bool
+v810_print_operand_punct_valid_p (unsigned char code)
+{
+  return code == '.';
+}
+
+/* When assemble_integer is used to emit the offsets for a switch
+   table it can encounter (TRUNCATE:HI (MINUS:SI (LABEL_REF:SI) (LABEL_REF:SI))).
+   output_addr_const will normally barf at this, but it is OK to omit
+   the truncate and just emit the difference of the two labels.  The
+   .hword directive will automatically handle the truncation for us.
+   
+   Returns true if rtx was handled, false otherwise.  */
+
+static bool
+v810_output_addr_const_extra (FILE * file, rtx x)
+{
+  if (GET_CODE (x) != TRUNCATE)
+    return false;
+
+  x = XEXP (x, 0);
+
+  /* We must also handle the case where the switch table was passed a
+     constant value and so has been collapsed.  In this case the first
+     label will have been deleted.  In such a case it is OK to emit
+     nothing, since the table will not be used.
+     (cf gcc.c-torture/compile/990801-1.c).  */
+  if (GET_CODE (x) == MINUS
+      && GET_CODE (XEXP (x, 0)) == LABEL_REF
+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == CODE_LABEL
+      && INSN_DELETED_P (XEXP (XEXP (x, 0), 0)))
+    return true;
+
+  output_addr_const (file, x);
+  return true;
+}
+
+/* Return appropriate code to load up a 1, 2, or 4 integer/floating
+   point value.  */
+
+const char *
+output_move_single (rtx * operands)
+{
+  rtx dst = operands[0];
+  rtx src = operands[1];
+
+  if (REG_P (dst))
+    {
+      if (REG_P (src))
+        return "mov %1,%0";
+
+      else if (GET_CODE (src) == CONST_INT)
+        {
+          HOST_WIDE_INT value = INTVAL (src);
+
+          if (CONST_OK_FOR_J (value))           /* Signed 5-bit immediate.  */
+            return "mov %1,%0";
+
+          else if (CONST_OK_FOR_K (value))      /* Signed 16-bit immediate.  */
+            return "movea %1,%.,%0";
+
+          else if (CONST_OK_FOR_L (value))      /* Upper 16 bits were set.  */
+            return "movhi hi0(%1),%.,%0";
+
+          /* A random constant.  */
+          else
+            return "movhi hi(%1),%.,%0\n\tmovea lo(%1),%0,%0";
+        }
+
+      else if (GET_CODE (src) == CONST_DOUBLE && GET_MODE (src) == SFmode)
+        {
+          HOST_WIDE_INT high, low;
+
+          const_double_split (src, &high, &low);
+
+          if (CONST_OK_FOR_J (high))            /* Signed 5-bit immediate.  */
+            return "mov %F1,%0";
+
+          else if (CONST_OK_FOR_K (high))       /* Signed 16-bit immediate.  */
+            return "movea %F1,%.,%0";
+
+          else if (CONST_OK_FOR_L (high))       /* Upper 16 bits were set.  */
+            return "movhi hi0(%F1),%.,%0";
+
+          /* A random constant.  */
+          else
+            return "movhi hi(%F1),%.,%0\n\tmovea lo(%F1),%0,%0";
+        }
+
+      else if (GET_CODE (src) == MEM)
+        return "%S1ld%W1 %1,%0";
+
+      else if (special_symbolref_operand (src, VOIDmode))
+        return "movea %O1(%P1),%Q1,%0";
+
+      else if (GET_CODE (src) == LABEL_REF
+               || GET_CODE (src) == SYMBOL_REF
+               || GET_CODE (src) == CONST)
+        {
+          return "movhi hi(%1),%.,%0\n\tmovea lo(%1),%0,%0";
+        }
+
+      else if (GET_CODE (src) == HIGH)
+        return "movhi hi(%1),%.,%0";
+
+      else if (GET_CODE (src) == LO_SUM)
+        {
+          operands[2] = XEXP (src, 0);
+          operands[3] = XEXP (src, 1);
+          return "movea lo(%3),%2,%0";
+        }
+    }
+
+  else if (GET_CODE (dst) == MEM)
+    {
+      if (REG_P (src))
+        return "%S0st%W0 %1,%0";
+
+      else if (GET_CODE (src) == CONST_INT && INTVAL (src) == 0)
+        return "%S0st%W0 %.,%0";
+
+      else if (GET_CODE (src) == CONST_DOUBLE
+               && CONST0_RTX (GET_MODE (dst)) == src)
+        return "%S0st%W0 %.,%0";
+    }
+
+  fatal_insn ("output_move_single:", gen_rtx_SET (VOIDmode, dst, src));
+  return "";
+}
+
+/* # of registers saved by the interrupt handler (R1).  */
+#define INTERRUPT_FIXED_NUM 1
+
+/* # of bytes for registers saved by the interrupt handler.  */
+#define INTERRUPT_FIXED_SAVE_SIZE (4 * INTERRUPT_FIXED_NUM)
+
+int
+compute_register_save_size (long * p_reg_saved)
+{
+  int size = 0;
+  int i;
+  int interrupt_handler = v810_interrupt_function_p (current_function_decl);
+  int fp_is_used_p = df_regs_ever_live_p (FP_REGNUM);
+  int lp_is_used_p = df_regs_ever_live_p (LP_REGNUM);
+  long reg_saved = 0;
+
+  /* Find the first callee-saved-register that needs to be saved.
+     The callee-saved registers are R20-R29, R29 allocated first.  */
+  for (i = 20; i <= 29; i++)
+    if (df_regs_ever_live_p (i))
+      break;
+
+  /* Prolog functions save all registers between the starting
+     register and the last register, regardless of whether they
+     are actually used by the function or not, so count the space.  */
+  for (; i <= 29; i++)
+    {
+      size += 4;
+      reg_saved |= 1L << i;
+    }
+
+  /* If we're saving FP, then also save LP (so we can backtrace).  */
+  /* Prolog functions save both FP and LP, and will always be invoked if
+     saving any callee-saved registers or the LP (i.e. we're not a leaf).  */
+  if (frame_pointer_needed || crtl->profile ||
+       (TARGET_PROLOG_FUNCTION && ((size != 0) || !crtl->is_leaf)))
+    {
+      if (! lp_is_used_p)
+        {
+          df_set_regs_ever_live (LP_REGNUM, true);
+          lp_is_used_p = 1;
+        }
+
+      if (! fp_is_used_p)
+        {
+          df_set_regs_ever_live (FP_REGNUM, true);
+          fp_is_used_p = 1;
+        }
+    }
+
+  /* Do we need to save the LP?  */
+  if (lp_is_used_p)
+    {
+      size += 4;
+      reg_saved |= 1L << LP_REGNUM;
+    }
+
+  /* Do we need to save the FP?  */
+  if (fp_is_used_p)
+    {
+      size += 4;
+      reg_saved |= 1L << FP_REGNUM;
+    }
+
+  /* An interrupt-handler needs to save everything that's used in this
+     function or could be used in functions that are called from here.  */
+  if (interrupt_handler)
+    {
+      bool save_all_scratch = crtl->profile || !crtl->is_leaf;
+
+      /* Count the scratch registers that are used (R6-R19 & R30).  */
+      for (i = 6; i <= 19; i++)
+        if (save_all_scratch || df_regs_ever_live_p (i))
+          {
+            size += 4;
+            reg_saved |= 1L << i;
+          }
+
+      if (save_all_scratch || df_regs_ever_live_p (30))
+        {
+          size += 4;
+          reg_saved |= 1L << 30;
+        }
+
+      /* Also count any special registers that are saved.  */
+      size += INTERRUPT_FIXED_SAVE_SIZE;
+    }
+
+  if (p_reg_saved)
+    *p_reg_saved = reg_saved;
+
+  return size;
+}
+
+/* Typical stack layout should looks like this after the function's prologue:
+
+                            |    |
+                              --                       ^
+                            |    | \                   |
+                            |    |   arguments saved   | Increasing
+                            |    |   on the stack      |  addresses
+    PARENT   arg pointer -> |    | /
+  -------------------------- ---- -------------------
+                            |    | - space for argument split between regs & stack
+			      --
+    CHILD                   |    | \ 
+                            |    |   other call
+                            |    |   saved registers
+                            |    |     <-- (return address here)
+                            |    | /   <-- (frame pointer here)
+                              --
+    (hard) frame pointer -> |    | \             ___
+                            |    |   local        |
+                            |    |   variables    |f
+                            |    | /              |r
+                              --                  |a
+                            |    | \              |m
+                            |    |   outgoing     |e
+                            |    |   arguments    |    | Decreasing
+                            |    |  /             |    |  addresses
+           stack pointer -> |    | /             _|_   |
+  -------------------------- ---- ------------------   V */
+
+int
+compute_frame_size (int size, long * p_reg_saved)
+{
+  return (size
+          + compute_register_save_size (p_reg_saved)
+          + crtl->outgoing_args_size);
+}
+
+void
+expand_prologue (void)
+{
+  unsigned int i;
+  unsigned int size = get_frame_size ();
+  int actual_fsize;
+  int init_stack_alloc = 0;
+  rtx save_regs[32];
+  rtx save_all;
+  unsigned int num_save;
+  int code;
+  int interrupt_handler = v810_interrupt_function_p (current_function_decl);
+  long reg_saved = 0;
+
+  actual_fsize = compute_frame_size (size, &reg_saved);
+
+  /* Identify all of the saved registers. */
+  num_save = 0;
+
+  /* An interrupt-handler needs to save everything that's used in this
+     function or could be used in functions that are called from here.  */
+  if (interrupt_handler)
+    {
+      /* Save special registers that might get trashed.  */
+      emit_insn (gen_save_interrupt ());
+
+      actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;
+
+      /* Save the scratch registers onto the stack in R6-R19 order. */
+      for (i = 6; i <= 19; i++)
+        {
+          if (((1L << i) & reg_saved) != 0)
+            save_regs[num_save++] = gen_rtx_REG (Pmode, i);
+        }
+
+      /* R30 is also a scratch register on the V810, save it next. */
+      if (((1L << 30) & reg_saved) != 0)
+        {
+          save_regs[num_save++] = gen_rtx_REG (Pmode, 30);
+        }
+    }
+
+  /* Listed here in reverse-order of allocation, low-to-high in memory. */
+  /* The reversal of order between prologue/epilogue is done later on. */
+
+  /* Save the callee-saved registers onto the stack in R20-R29 order. */
+  for (i = 20; i <= 29; i++)
+    {
+      if (((1L << i) & reg_saved) != 0)
+    save_regs[num_save++] = gen_rtx_REG (Pmode, i);
+    }
+
+  /* If the LP register is to be saved, save it next. */
+  if (((1L << LP_REGNUM) & reg_saved) != 0)
+    {
+      save_regs[num_save++] = gen_rtx_REG (Pmode, LP_REGNUM);
+    }
+
+  /* If the FP register is to be saved, save it next. */
+  if (((1L << FP_REGNUM) & reg_saved) != 0)
+    {
+      save_regs[num_save++] = gen_rtx_REG (Pmode, FP_REGNUM);
+    }
+
+  /* See if we have a helper-function insn that allocates stack space and
+     saves the particular registers we want to.  */
+  /* Note that the helpers won't allocate additional space for registers
+     GCC saves to complete a "split" structure argument.  */
+  /* But not in an interrupt_handler, which does a lot of special-case stuff!  */
+  save_all = NULL_RTX;
+
+  if (TARGET_PROLOG_FUNCTION
+      && (((1L << FP_REGNUM) & reg_saved) != 0)
+      && (num_save > 0)
+      && !interrupt_handler)
+    {
+      if (1)
+        {
+          int alloc_stack = 4 * num_save;
+          int offset = alloc_stack;
+
+          save_all = gen_rtx_PARALLEL
+            (VOIDmode,
+             rtvec_alloc (num_save + 3));
+
+          XVECEXP (save_all, 0, 0)
+            = gen_rtx_SET (VOIDmode,
+                           stack_pointer_rtx,
+                           gen_rtx_PLUS (Pmode,
+                                         stack_pointer_rtx,
+                                         GEN_INT(-alloc_stack)));
+
+          XVECEXP (save_all, 0, 1)
+            = gen_rtx_SET (VOIDmode,
+                           frame_pointer_rtx,
+                           stack_pointer_rtx);
+
+          for (i = 0; i < num_save; i++)
+            {
+              offset -= 4;
+
+              XVECEXP (save_all, 0, i+2)
+                = gen_rtx_SET (VOIDmode,
+                               gen_rtx_MEM (Pmode,
+                                            gen_rtx_PLUS (Pmode,
+                                                          stack_pointer_rtx,
+                                                          GEN_INT(offset))),
+                               save_regs[i]);
+            }
+
+          XVECEXP (save_all, 0, num_save + 2)
+            = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 1));
+
+          code = recog (save_all, NULL_RTX, NULL);
+
+          if (code >= 0)
+            {
+              rtx insn = emit_insn (save_all);
+              INSN_CODE (insn) = code;
+
+              actual_fsize -= alloc_stack;
+              
+              if (TARGET_DEBUG)
+                fprintf (stderr, "Prologue matched for function %s\n",
+                         IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+            }
+          else
+            {
+              if (TARGET_DEBUG)
+                fprintf (stderr, "Prologue failed for function %s\n",
+                         IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+              save_all = NULL_RTX;
+            }
+        }
+    }
+
+  /* If no prolog save function is available, store the registers the old
+     fashioned way (one by one).  */
+  if (!save_all)
+    {
+      int offset;
+
+      /* If the stack is too big, allocate it in chunks so we can do the
+         register saves.  Also needed if saving the frame pointer.  */
+      if ((actual_fsize && !CONST_OK_FOR_K (-actual_fsize)) ||
+          (((1L << FP_REGNUM) & reg_saved) != 0))
+        init_stack_alloc = (4 * num_save);
+      else
+        init_stack_alloc = actual_fsize;
+
+      /* Save registers at the top of the stack frame.  */
+      offset = init_stack_alloc;
+
+      /* Save registers, with FP_REGNUM last at the lowest address,
+         then LP_REGNUM, then followed by the rest in allocation order. */
+      if (init_stack_alloc)
+        {
+          emit_insn (gen_addsi3 (stack_pointer_rtx,
+                                 stack_pointer_rtx,
+                                 GEN_INT (- init_stack_alloc)));
+        }
+
+      for (i = 0; i < num_save; i++)
+        {
+          offset -= 4;
+          emit_move_insn (gen_rtx_MEM (SImode,
+					      plus_constant (Pmode,
+							     stack_pointer_rtx,
+							     offset)),
+                          save_regs[i]);
+        }
+
+      /* Do we need a frame pointer?  */
+      if (((1L << FP_REGNUM) & reg_saved) != 0)
+        {
+          /* Copy SP to FP now.  */
+          emit_move_insn (
+            frame_pointer_rtx,
+            stack_pointer_rtx);
+        }
+    }
+
+  /* Allocate the rest of the stack that was not allocated above (either it is
+     > 32K or we just called a function to save the registers and needed more
+     stack.  */
+  if (actual_fsize > init_stack_alloc)
+    {
+      int diff = actual_fsize - init_stack_alloc;
+      if (CONST_OK_FOR_K (-diff))
+        emit_insn (gen_addsi3 (stack_pointer_rtx,
+                               stack_pointer_rtx,
+                               GEN_INT (-diff)));
+      else
+        {
+          rtx reg = gen_rtx_REG (Pmode, 12);
+          emit_move_insn (reg, GEN_INT (-diff));
+          emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));
+        }
+    }
+
+  /* Emit a barrier to prevent GCC's oh-so-clever scheduler from
+     moving stores to the frame before the stack adjustment.  */
+  emit_insn (gen_blockage ());
+}
+
+void
+expand_epilogue (void)
+{
+  unsigned int i;
+  unsigned int size = get_frame_size ();
+  long reg_saved = 0;
+  int actual_fsize = compute_frame_size (size, &reg_saved);
+  rtx restore_regs[32];
+  rtx restore_all;
+  unsigned int num_restore;
+  int code;
+  int interrupt_handler = v810_interrupt_function_p (current_function_decl);
+
+  /* Identify all of the saved registers.  */
+  num_restore = 0;
+
+  /* An interrupt-handler needs to restore everything that's used in this
+     function or could be used in functions that are called from here.  */
+  if (interrupt_handler)
+    {
+      actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;
+
+      /* Save the scratch registers onto the stack in R6-R19 order. */
+      for (i = 6; i <= 19; i++)
+        {
+          if (((1L << i) & reg_saved) != 0)
+            restore_regs[num_restore++] = gen_rtx_REG (Pmode, i);
+        }
+
+      /* R30 is also a scratch register on the V810, save it next. */
+      if (((1L << 30) & reg_saved) != 0)
+        {
+          restore_regs[num_restore++] = gen_rtx_REG (Pmode, 30);
+        }
+    }
+
+  /* Listed here in reverse-order of allocation, low-to-high in memory. */
+  /* The reversal of order between prologue/epilogue is done later on. */
+
+  /* Load the callee-saved registers from the stack in R20-R29 order. */
+  for (i = 20; i <= 29; i++)
+    {
+      if (((1L << i) & reg_saved) != 0)
+        restore_regs[num_restore++] = gen_rtx_REG (Pmode, i);
+    }
+
+  /* If the LP register is to be restored, load it now. */
+  if (((1L << LP_REGNUM) & reg_saved) != 0)
+    {
+      restore_regs[num_restore++] = gen_rtx_REG (Pmode, LP_REGNUM);
+    }
+
+  /* If the FP register is to be restored, load it now. */
+  if (((1L << FP_REGNUM) & reg_saved) != 0)
+    {
+      restore_regs[num_restore++] = gen_rtx_REG (Pmode, FP_REGNUM);
+    }
+
+  /* See if we have a helper-function insn that restores the particular
+     registers that we want to.  */
+  /* But not in an interrupt_handler, which does a lot of special-case stuff!  */
+  restore_all = NULL_RTX;
+
+  if (TARGET_PROLOG_FUNCTION
+      && (((1L << FP_REGNUM) & reg_saved) != 0)
+      && !interrupt_handler)
+    {
+      if (1)
+        {
+          int alloc_stack = 4 * num_restore;
+          int offset = alloc_stack;
+
+          restore_all = gen_rtx_PARALLEL (VOIDmode,
+                                          rtvec_alloc (num_restore + 3));
+
+          XVECEXP (restore_all, 0, 0) = ret_rtx;
+
+          XVECEXP (restore_all, 0, 1)
+            = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+                            gen_rtx_PLUS (Pmode,
+                                          frame_pointer_rtx,
+                                          GEN_INT (alloc_stack)));
+
+          for (i = 0; i < num_restore; i++)
+            {
+              offset -= 4;
+
+              XVECEXP (restore_all, 0, i+2)
+                = gen_rtx_SET (VOIDmode,
+                               restore_regs[i],
+                               gen_rtx_MEM (Pmode,
+                                            gen_rtx_PLUS (Pmode,
+                                                          frame_pointer_rtx,
+                                                          GEN_INT(offset))));
+            }
+
+          XVECEXP (restore_all, 0, num_restore + 2)
+            = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 1));
+
+          code = recog (restore_all, NULL_RTX, NULL);
+          
+          if (code >= 0)
+            {
+              rtx insn = emit_jump_insn (restore_all);
+              INSN_CODE (insn) = code;
+
+              if (TARGET_DEBUG)
+                fprintf (stderr, "Epilogue matched for function %s\n",
+                         IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+            }
+          else
+            {
+              if (TARGET_DEBUG)
+                fprintf (stderr, "Epilogue failed for function %s\n",
+                         IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+              restore_all = NULL_RTX;
+            }
+        }
+    }
+
+  /* If no epilogue save function is available, restore the registers the
+     old fashioned way (one by one).  */
+  if (!restore_all)
+    {
+      if (((1L << FP_REGNUM) & reg_saved) != 0)
+        {
+          /* Restore registers from the top of the stack frame.  */
+          int offset = (4 * num_restore);
+
+          /* Calculate final SP address from the current FP.  */
+          emit_insn (gen_addsi3 (gen_rtx_REG (Pmode, 1),
+                                 frame_pointer_rtx,
+                                 GEN_INT (offset)));
+
+          /* Restore registers, with FP_REGNUM last at the lowest address,
+             then LP_REGNUM, then followed by the rest in allocation order. */
+          for (i = 0; i < num_restore; i++)
+            {
+              offset -= 4;
+
+              emit_move_insn (restore_regs[i],
+			      gen_rtx_MEM (SImode,
+					   plus_constant (Pmode,
+							  frame_pointer_rtx,
+							  offset)));
+              emit_use (restore_regs[i]);
+            }
+
+          /* Emit a barrier to prevent GCC's oh-so-clever scheduler from
+             moving loads from the frame after the stack adjustment.  */
+          emit_insn (gen_blockage ());
+
+          /* Update final SP address from the R1 temporary.  */
+          emit_move_insn (
+            stack_pointer_rtx,
+            gen_rtx_REG (Pmode, 1));
+        }
+      else
+        {
+          unsigned int init_stack_free;
+          int offset;
+
+          /* If the stack is large, we need to cut it down in 2 pieces.  */
+#if 0 // JCB - This seems wrong, it needs to be tested!
+          if (interrupt_handler)
+            init_stack_free = 0;
+          else
+#endif
+          if (actual_fsize && !CONST_OK_FOR_K (-actual_fsize))
+            init_stack_free = (4 * num_restore);
+          else
+            init_stack_free = actual_fsize;
+    
+          /* Deallocate the rest of the stack if it is > 32K.  */
+          if ((unsigned int) actual_fsize > init_stack_free)
+            {
+              int diff;
+    
+              diff = actual_fsize - init_stack_free;
+    
+              if (CONST_OK_FOR_K (diff))
+                emit_insn (gen_addsi3 (stack_pointer_rtx,
+                                       stack_pointer_rtx,
+                                       GEN_INT (diff)));
+              else
+                {
+                  rtx reg = gen_rtx_REG (Pmode, 1);
+                  emit_move_insn (reg, GEN_INT (diff));
+                  emit_insn (gen_addsi3 (stack_pointer_rtx,
+                                         stack_pointer_rtx,
+                                         reg));
+                }
+            }
+
+          /* Restore registers from the beginning of the stack frame.  */
+          offset = init_stack_free;
+
+          /* Restore registers, with FP_REGNUM last at the lowest address,
+             then LP_REGNUM, then followed by the rest in allocation order. */
+          for (i = 0; i < num_restore; i++)
+            {
+              offset -= 4;
+              emit_move_insn (restore_regs[i],
+			      gen_rtx_MEM (SImode,
+					   plus_constant (Pmode,
+							  stack_pointer_rtx,
+							  offset)));
+
+              emit_use (restore_regs[i]);
+            }
+
+          /* Cut back the remainder of the stack.  */
+          if (init_stack_free)
+            {
+              emit_insn (gen_addsi3 (stack_pointer_rtx,
+                                     stack_pointer_rtx,
+                                     GEN_INT (init_stack_free)));
+            }
+        }
+
+      /* And return or use reti for interrupt handlers.  */
+      if (interrupt_handler)
+        {
+          emit_jump_insn (gen_return_interrupt ());
+        }
+      else if (actual_fsize)
+        emit_jump_insn (gen_return_internal ());
+      else
+        emit_jump_insn (gen_return_simple ());
+    }
+
+  v810_interrupt_cache_p = FALSE;
+  v810_interrupt_p = FALSE;
+}
+
+/* Update the condition code from the insn.  */
+void
+notice_update_cc (rtx body, rtx insn)
+{
+  switch (get_attr_cc (insn))
+    {
+    case CC_NONE:
+      /* Insn does not affect CC at all.  */
+      break;
+
+    case CC_NONE_0HIT:
+      /* Insn does not change CC, but the 0'th operand has been changed.  */
+      if (cc_status.value1 != 0
+          && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))
+        cc_status.value1 = 0;
+      break;
+
+    case CC_SET_ZN:
+      /* Insn sets the Z,N flags of CC to recog_data.operand[0].
+         V,C is in an unusable state.  */
+      CC_STATUS_INIT;
+      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;
+      cc_status.value1 = recog_data.operand[0];
+      break;
+
+    case CC_SET_ZNV:
+      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].
+         C is in an unusable state.  */
+      CC_STATUS_INIT;
+      cc_status.flags |= CC_NO_CARRY;
+      cc_status.value1 = recog_data.operand[0];
+      break;
+
+    case CC_COMPARE:
+      /* The insn is a compare instruction.  */
+      CC_STATUS_INIT;
+      cc_status.value1 = SET_SRC (body);
+      break;
+
+    case CC_CLOBBER:
+      /* Insn doesn't leave CC in a usable state.  */
+      CC_STATUS_INIT;
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Retrieve the data area that has been chosen for the given decl.  */
+
+v810_data_area
+v810_get_data_area (tree decl)
+{
+  if (lookup_attribute ("sda", DECL_ATTRIBUTES (decl)) != NULL_TREE)
+    return DATA_AREA_SDA;
+  
+  if (lookup_attribute ("tda", DECL_ATTRIBUTES (decl)) != NULL_TREE)
+    return DATA_AREA_TDA;
+  
+  if (lookup_attribute ("zda", DECL_ATTRIBUTES (decl)) != NULL_TREE)
+    return DATA_AREA_ZDA;
+
+  return DATA_AREA_NORMAL;
+}
+
+/* Store the indicated data area in the decl's attributes.  */
+
+static void
+v810_set_data_area (tree decl, v810_data_area data_area)
+{
+  tree name;
+  
+  switch (data_area)
+    {
+    case DATA_AREA_SDA: name = get_identifier ("sda"); break;
+    case DATA_AREA_TDA: name = get_identifier ("tda"); break;
+    case DATA_AREA_ZDA: name = get_identifier ("zda"); break;
+    default:
+      return;
+    }
+
+  DECL_ATTRIBUTES (decl) = tree_cons
+    (name, NULL, DECL_ATTRIBUTES (decl));
+}
+
+/* Handle an "interrupt" attribute; arguments as in
+   struct attribute_spec.handler.  */
+static tree
+v810_handle_interrupt_attribute (tree * node,
+                                 tree name,
+                                 tree args ATTRIBUTE_UNUSED,
+                                 int flags ATTRIBUTE_UNUSED,
+                                 bool * no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+               name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Handle a "sda", "tda" or "zda" attribute; arguments as in
+   struct attribute_spec.handler.  */
+static tree
+v810_handle_data_area_attribute (tree* node,
+                                 tree name,
+                                 tree args ATTRIBUTE_UNUSED,
+                                 int flags ATTRIBUTE_UNUSED,
+                                 bool * no_add_attrs)
+{
+  v810_data_area data_area;
+  v810_data_area area;
+  tree decl = *node;
+
+  /* Implement data area attribute.  */
+  if (is_attribute_p ("sda", name))
+    data_area = DATA_AREA_SDA;
+  else if (is_attribute_p ("tda", name))
+    data_area = DATA_AREA_TDA;
+  else if (is_attribute_p ("zda", name))
+    data_area = DATA_AREA_ZDA;
+  else
+    gcc_unreachable ();
+  
+  switch (TREE_CODE (decl))
+    {
+    case VAR_DECL:
+      if (current_function_decl != NULL_TREE)
+        {
+          error_at (DECL_SOURCE_LOCATION (decl),
+                    "data area attributes cannot be specified for "
+                    "local variables");
+          *no_add_attrs = true;
+        }
+
+      /* Drop through.  */
+
+    case FUNCTION_DECL:
+      area = v810_get_data_area (decl);
+      if (area != DATA_AREA_NORMAL && data_area != area)
+        {
+          error ("data area of %q+D conflicts with previous declaration",
+                 decl);
+          *no_add_attrs = true;
+        }
+      break;
+      
+    default:
+      break;
+    }
+
+  return NULL_TREE;
+}
+
+
+/* Return nonzero if FUNC is an interrupt function as specified
+   by the "interrupt" attribute.  */
+
+int
+v810_interrupt_function_p (tree func)
+{
+  tree a;
+  int ret = 0;
+
+  if (v810_interrupt_cache_p)
+    return v810_interrupt_p;
+
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return 0;
+
+  a = lookup_attribute ("interrupt_handler", DECL_ATTRIBUTES (func));
+  if (a != NULL_TREE)
+    ret = 1;
+
+  else
+    {
+      a = lookup_attribute ("interrupt", DECL_ATTRIBUTES (func));
+      ret = a != NULL_TREE;
+    }
+
+  /* Its not safe to trust global variables until after function inlining has
+     been done.  */
+  if (reload_completed | reload_in_progress)
+    v810_interrupt_p = ret;
+
+  return ret;
+}
+
+
+static void
+v810_encode_data_area (tree decl, rtx symbol)
+{
+  int flags;
+
+  /* Map explicit sections into the appropriate attribute */
+  if (v810_get_data_area (decl) == DATA_AREA_NORMAL)
+    {
+      if (DECL_SECTION_NAME (decl))
+        {
+          const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+          
+          if (streq (name, ".zdata") || streq (name, ".zbss"))
+            v810_set_data_area (decl, DATA_AREA_ZDA);
+
+          else if (streq (name, ".sdata") || streq (name, ".sbss"))
+            v810_set_data_area (decl, DATA_AREA_SDA);
+
+          else if (streq (name, ".tdata"))
+            v810_set_data_area (decl, DATA_AREA_TDA);
+        }
+
+      /* If no attribute, support -m{zda,sda}=n */
+      else
+        {
+          int size = int_size_in_bytes (TREE_TYPE (decl));
+          if (size <= 0)
+            ;
+
+          /* DATA_AREA_TDA is never automatic on the V810 */
+
+          else if (size <= small_memory_max [(int) SMALL_MEMORY_SDA])
+            v810_set_data_area (decl, DATA_AREA_SDA);
+
+          else if (size <= small_memory_max [(int) SMALL_MEMORY_ZDA])
+            v810_set_data_area (decl, DATA_AREA_ZDA);
+        }
+      
+      if (v810_get_data_area (decl) == DATA_AREA_NORMAL)
+        return;
+    }
+
+  flags = SYMBOL_REF_FLAGS (symbol);
+  switch (v810_get_data_area (decl))
+    {
+    case DATA_AREA_ZDA: flags |= SYMBOL_FLAG_ZDA; break;
+    case DATA_AREA_TDA: flags |= SYMBOL_FLAG_TDA; break;
+    case DATA_AREA_SDA: flags |= SYMBOL_FLAG_SDA; break;
+    default: gcc_unreachable ();
+    }
+  SYMBOL_REF_FLAGS (symbol) = flags;
+}
+
+static void
+v810_encode_section_info (tree decl, rtx rtl, int first)
+{
+  default_encode_section_info (decl, rtl, first);
+
+  if (TREE_CODE (decl) == VAR_DECL
+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+    v810_encode_data_area (decl, XEXP (rtl, 0));
+}
+
+/* Construct a JR instruction to a routine that will perform the equivalent of
+   the RTL passed in as an argument.  This RTL is a function epilogue that
+   pops registers off the stack and possibly releases some extra stack space
+   as well.  The code has already verified that the RTL matches these
+   requirements.  */
+/* N.B. Heavily modified from V850 for V810 stack frame, and frame pointer.  */
+
+char *
+construct_restore_jr (rtx op)
+{
+  int count = XVECLEN (op, 0);
+  int stack_bytes;
+  unsigned long int mask;
+  unsigned long int first;
+  int i;
+  static char buff [100]; /* XXX */
+
+  if (count <= 3)
+    {
+      error ("bogus JR construction: %d", count);
+      return NULL;
+    }
+
+  /* Paranoia.  */
+  gcc_assert (GET_CODE (XVECEXP (op, 0, 1)) == SET);
+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS);
+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 0)) == REG);
+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) == CONST_INT);
+    
+  /* Work out how many bytes to pop off the stack before retrieving
+     registers.  */
+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1));
+
+  /* Each pop will remove 4 bytes from the stack....  */
+  stack_bytes -= (count - 3) * 4;
+
+  /* Make sure that the amount we are popping is 0 bytes.  */
+  if (stack_bytes != 0)
+    {
+      error ("bad amount of stack space adjustment: %d", stack_bytes);
+      return NULL;
+    }
+
+  /* Now compute the bit mask of registers to pop.  */
+  mask = 0;
+  for (i = 2; i < count - 1; i++)
+    {
+      rtx vector_element = XVECEXP (op, 0, i);
+      
+      gcc_assert (GET_CODE (vector_element) == SET);
+      gcc_assert (GET_CODE (SET_DEST (vector_element)) == REG);
+      gcc_assert (register_is_ok_for_epilogue (SET_DEST (vector_element),
+                                               SImode));
+      
+      mask |= 1 << REGNO (SET_DEST (vector_element));
+    }
+
+  /* Scan for the first register to pop (skip R1 & FP).  */
+  for (first = 3; first < 32; first++)
+    {
+      if (mask & (1 << first))
+        break;
+    }
+
+  gcc_assert (first > 19);
+  gcc_assert (first < 32);
+
+  /* Note, it is possible to have gaps in the register mask.
+     We ignore this here, and generate a JR anyway.  We will
+     be popping more registers than is strictly necessary, but
+     it does save code space.  */
+  
+  sprintf (buff, "jr __load_r%lu_fp", first);
+
+  if (TARGET_DEBUG)
+    fprintf (stderr, "construct_restore_jr outputs \"%s\" for function %s\n",
+             buff, IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+  
+  return buff;
+}
+
+
+/* Construct a JAL instruction to a routine that will perform the equivalent
+   of the RTL passed as a parameter.  This RTL is a function prologue that
+   saves some of the registers r20 - r31 onto the stack, and possibly acquires
+   some stack space as well.  The code has already verified that the RTL
+   matches these requirements.  */
+/* N.B. Heavily modified from V850 for V810 stack frame, and frame pointer.  */
+
+char *
+construct_save_jal (rtx op)
+{
+  int count = XVECLEN (op, 0);
+  int stack_bytes;
+  unsigned long int mask;
+  unsigned long int first;
+  int i;
+  static char buff [100]; /* XXX */
+  
+  if (count <= 3) 
+    {
+      error ("bogus JAL construction: %d", count);
+      return NULL;
+    }
+
+  /* Paranoia.  */
+  gcc_assert (GET_CODE (XVECEXP (op, 0, 0)) == SET);
+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) == PLUS);
+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0)) == REG);
+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) == CONST_INT);
+
+  gcc_assert (GET_CODE (XVECEXP (op, 0, 1)) == SET);
+    
+  /* Work out how many bytes to push onto the stack after storing the
+     registers.  */
+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));
+
+  /* Each push will put 4 bytes from the stack....  */
+  stack_bytes += (count - 3) * 4;
+
+  /* Make sure that the integer in the stack adjust matches the number
+     of registers that we are saving.  */
+  if (stack_bytes != 0)
+    {
+      error ("bad amount of stack space adjustment: %d", stack_bytes);
+      return NULL;
+    }
+
+  /* Now compute the bit mask of registers to push.  */
+  mask = 0;
+  for (i = 2; i < count - 1; i++)
+    {
+      rtx vector_element = XVECEXP (op, 0, i);
+      
+      gcc_assert (GET_CODE (vector_element) == SET);
+      gcc_assert (GET_CODE (SET_SRC (vector_element)) == REG);
+      gcc_assert (register_is_ok_for_epilogue (SET_SRC (vector_element),
+                                               SImode));
+      
+      mask |= 1 << REGNO (SET_SRC (vector_element));
+    }
+
+  /* Scan for the first register to push (skip R1 & FP).  */  
+  for (first = 3; first < 32; first++)
+    {
+      if (mask & (1 << first))
+        break;
+    }
+
+  gcc_assert (first > 19);
+  gcc_assert (first < 32);
+
+  /* Note, it is possible to have gaps in the register mask.
+     We ignore this here, and generate a JAL anyway.  We will
+     be pushing more registers than is strictly necessary, but
+     it does save code space.  */
+  
+  sprintf (buff, "mov lp, r1\n\tjal __save_r%lu_fp", first);
+
+  if (TARGET_DEBUG)
+    fprintf (stderr, "construct_save_jal \"%s\" for function %s\n",
+             buff, IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+
+  return buff;
+}
+
+extern tree last_assemble_variable_decl;
+extern int size_directive_output;
+
+/* A version of asm_output_aligned_bss() that copes with the special
+   data areas of the v810.  */
+void
+v810_output_aligned_bss (FILE * file,
+                         tree decl,
+                         const char * name,
+                         unsigned HOST_WIDE_INT size,
+                         int align)
+{
+  switch (v810_get_data_area (decl))
+    {
+    case DATA_AREA_ZDA:
+      switch_to_section (zbss_section);
+      break;
+
+    case DATA_AREA_SDA:
+      switch_to_section (sbss_section);
+      break;
+
+    case DATA_AREA_TDA:
+      switch_to_section (tdata_section);
+      break;
+      
+    default:
+      switch_to_section (bss_section);
+      break;
+    }
+  
+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
+#ifdef ASM_DECLARE_OBJECT_NAME
+  last_assemble_variable_decl = decl;
+  ASM_DECLARE_OBJECT_NAME (file, name, decl);
+#else
+  /* Standard thing is just output label for the object.  */
+  ASM_OUTPUT_LABEL (file, name);
+#endif /* ASM_DECLARE_OBJECT_NAME */
+  ASM_OUTPUT_SKIP (file, size ? size : 1);
+}
+
+/* Called via the macro ASM_OUTPUT_DECL_COMMON */
+void
+v810_output_common (FILE * file,
+                    tree decl,
+                    const char * name,
+                    int size,
+                    int align)
+{
+  if (decl == NULL_TREE)
+    {
+      fprintf (file, "%s", COMMON_ASM_OP);
+    }
+  else
+    {
+      switch (v810_get_data_area (decl))
+        {
+        case DATA_AREA_ZDA:
+          fprintf (file, "%s", ZCOMMON_ASM_OP);
+          break;
+
+        case DATA_AREA_SDA:
+          fprintf (file, "%s", SCOMMON_ASM_OP);
+          break;
+
+        case DATA_AREA_TDA:
+          fprintf (file, "%s", TCOMMON_ASM_OP);
+          break;
+      
+        default:
+          fprintf (file, "%s", COMMON_ASM_OP);
+          break;
+        }
+    }
+  
+  assemble_name (file, name);
+  fprintf (file, ",%u,%u\n", size, align / BITS_PER_UNIT);
+}
+
+/* Called via the macro ASM_OUTPUT_DECL_LOCAL */
+void
+v810_output_local (FILE * file,
+                   tree decl,
+                   const char * name,
+                   int size,
+                   int align)
+{
+  fprintf (file, "%s", LOCAL_ASM_OP);
+  assemble_name (file, name);
+  fprintf (file, "\n");
+  
+  ASM_OUTPUT_ALIGNED_DECL_COMMON (file, decl, name, size, align);
+}
+
+/* Add data area to the given declaration if a ghs data area pragma is
+   currently in effect (#pragma ghs startXXX/endXXX).  */
+static void
+v810_insert_attributes (tree decl, tree * attr_ptr ATTRIBUTE_UNUSED )
+{
+  if (data_area_stack
+      && data_area_stack->data_area
+      && current_function_decl == NULL_TREE
+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)
+      && v810_get_data_area (decl) == DATA_AREA_NORMAL)
+    v810_set_data_area (decl, data_area_stack->data_area);
+
+  /* Initialize the default names of the v810 specific sections,
+     if this has not been done before.  */
+  
+  if (GHS_default_section_names [(int) GHS_SECTION_KIND_SDATA] == NULL)
+    {
+      GHS_default_section_names [(int) GHS_SECTION_KIND_SDATA]
+        = build_string (sizeof (".sdata")-1, ".sdata");
+
+      GHS_default_section_names [(int) GHS_SECTION_KIND_ROSDATA]
+        = build_string (sizeof (".rosdata")-1, ".rosdata");
+
+      GHS_default_section_names [(int) GHS_SECTION_KIND_TDATA]
+        = build_string (sizeof (".tdata")-1, ".tdata");
+      
+      GHS_default_section_names [(int) GHS_SECTION_KIND_ZDATA]
+        = build_string (sizeof (".zdata")-1, ".zdata");
+
+      GHS_default_section_names [(int) GHS_SECTION_KIND_ROZDATA]
+        = build_string (sizeof (".rozdata")-1, ".rozdata");
+    }
+  
+  if (current_function_decl == NULL_TREE
+      && (TREE_CODE (decl) == VAR_DECL
+          || TREE_CODE (decl) == CONST_DECL
+          || TREE_CODE (decl) == FUNCTION_DECL)
+      && (!DECL_EXTERNAL (decl) || DECL_INITIAL (decl))
+      && !DECL_SECTION_NAME (decl))
+    {
+      enum GHS_section_kind kind = GHS_SECTION_KIND_DEFAULT;
+      tree chosen_section;
+
+      if (TREE_CODE (decl) == FUNCTION_DECL)
+        kind = GHS_SECTION_KIND_TEXT;
+      else
+        {
+          /* First choose a section kind based on the data area of the decl.  */
+          switch (v810_get_data_area (decl))
+            {
+            default:
+              gcc_unreachable ();
+              
+            case DATA_AREA_SDA:
+              kind = ((TREE_READONLY (decl))
+                      ? GHS_SECTION_KIND_ROSDATA
+                      : GHS_SECTION_KIND_SDATA);
+              break;
+              
+            case DATA_AREA_TDA:
+              kind = GHS_SECTION_KIND_TDATA;
+              break;
+              
+            case DATA_AREA_ZDA:
+              kind = ((TREE_READONLY (decl))
+                      ? GHS_SECTION_KIND_ROZDATA
+                      : GHS_SECTION_KIND_ZDATA);
+              break;
+              
+            case DATA_AREA_NORMAL:               /* default data area */
+              if (TREE_READONLY (decl))
+                kind = GHS_SECTION_KIND_RODATA;
+              else if (DECL_INITIAL (decl))
+                kind = GHS_SECTION_KIND_DATA;
+              else
+                kind = GHS_SECTION_KIND_BSS;
+            }
+        }
+
+      /* Now, if the section kind has been explicitly renamed,
+         then attach a section attribute.  */
+      chosen_section = GHS_current_section_names [(int) kind];
+
+      /* Otherwise, if this kind of section needs an explicit section
+         attribute, then also attach one.  */
+      if (chosen_section == NULL)
+        chosen_section = GHS_default_section_names [(int) kind];
+
+      if (chosen_section)
+        {
+          /* Only set the section name if specified by a pragma, because
+             otherwise it will force those variables to get allocated storage
+             in this module, rather than by the linker.  */
+          DECL_SECTION_NAME (decl) = chosen_section;
+        }
+    }
+}
+
+/* Return an RTX indicating where the return address to the
+   calling function can be found.  */
+
+rtx
+v810_return_addr (int count)
+{
+  if (count != 0)
+    return const0_rtx;
+
+  return get_hard_reg_initial_val (Pmode, LINK_POINTER_REGNUM);
+}
+
+/* Implement TARGET_ASM_INIT_SECTIONS.  */
+
+static void
+v810_asm_init_sections (void)
+{
+  rosdata_section
+    = get_unnamed_section (0, output_section_asm_op,
+                           "\t.section .rosdata,\"a\"");
+
+  rozdata_section
+    = get_unnamed_section (0, output_section_asm_op,
+                           "\t.section .rozdata,\"a\"");
+
+  tdata_section
+    = get_unnamed_section (SECTION_WRITE, output_section_asm_op,
+                           "\t.section .tdata,\"aw\"");
+
+  zdata_section
+    = get_unnamed_section (SECTION_WRITE, output_section_asm_op,
+                           "\t.section .zdata,\"aw\"");
+
+  zbss_section
+    = get_unnamed_section (SECTION_WRITE | SECTION_BSS,
+                           output_section_asm_op,
+                           "\t.section .zbss,\"aw\"");
+}
+
+static section *
+v810_select_section (tree exp,
+                     int reloc ATTRIBUTE_UNUSED,
+                     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  if (TREE_CODE (exp) == VAR_DECL)
+    {
+      int is_const;
+      if (!TREE_READONLY (exp)
+          || TREE_SIDE_EFFECTS (exp)
+          || !DECL_INITIAL (exp)
+          || (DECL_INITIAL (exp) != error_mark_node
+              && !TREE_CONSTANT (DECL_INITIAL (exp))))
+        is_const = FALSE;
+      else
+        is_const = TRUE;
+
+      switch (v810_get_data_area (exp))
+        {
+        case DATA_AREA_ZDA:
+          return is_const ? rozdata_section : zdata_section;
+
+        case DATA_AREA_TDA:
+          return tdata_section;
+
+        case DATA_AREA_SDA:
+          return is_const ? rosdata_section : sdata_section;
+
+        default:
+          return is_const ? readonly_data_section : data_section;
+        }
+    }
+  return readonly_data_section;
+}
+
+/* Worker function for TARGET_FUNCTION_VALUE_REGNO_P.  */
+
+static bool
+v810_function_value_regno_p (const unsigned int regno)
+{
+  return (regno == 10);
+}
+
+/* Worker function for TARGET_RETURN_IN_MEMORY.  */
+
+static bool
+v810_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  /* Return values > 8 bytes in length in memory.  */
+  return int_size_in_bytes (type) > 8 || TYPE_MODE (type) == BLKmode;
+}
+
+/* Worker function for TARGET_FUNCTION_VALUE.  */
+
+static rtx
+v810_function_value (const_tree valtype, 
+                    const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
+                    bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (TYPE_MODE (valtype), 10);
+}
+
+
+/* Worker function for TARGET_FRAME_POINTER_REQUIRED.  */
+
+static bool
+v810_frame_pointer_required (void)
+{
+  /* V810 - New function for new frame layout and new prolog functions.  */
+
+  /* FP is really only *needed* if the stack frame has variable length,
+     i.e. alloca() or variable sized local arguments (GNU C extension).  */
+  if (!crtl->sp_is_unchanging)
+    return true;
+
+  /* Also needed if we're going to call a profiling function.  */
+  /* N.B. ... not really sure about this one.  */
+  if (crtl->profile)
+    return true;
+
+  /* If TARGET_PROLOG_FUNCTION, then the FP is always saved when we're
+     saving the LP (i.e. we're not a leaf function).  */
+  if (TARGET_PROLOG_FUNCTION && !crtl->is_leaf)
+    return true;
+
+  /* V810 - These MAY be something that effects us, but I don't know.  */
+  /* cfun->has_nonlocal_label  */
+  /* crtl->calls_eh_return  */
+
+  return false;
+}
+
+/* Worker function for TARGET_CAN_ELIMINATE.  */
+
+static bool
+v810_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
+{
+  return (to == STACK_POINTER_REGNUM ? ! frame_pointer_needed : true);
+}
+
+/* Worker function for INITIAL_ELIMINATION_OFFSET.  */
+
+HOST_WIDE_INT
+v810_initial_elimination_offset (int from, int to)
+{
+  HOST_WIDE_INT saved_size = compute_register_save_size ((long *)0);
+  HOST_WIDE_INT frame_size = get_frame_size () + crtl->outgoing_args_size;
+
+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)
+    return saved_size;
+  else
+    {
+      gcc_assert (to == STACK_POINTER_REGNUM);
+      if (from == ARG_POINTER_REGNUM)
+        return frame_size + saved_size;
+      else
+      if (from == FRAME_POINTER_REGNUM)
+        return frame_size;
+      else
+        gcc_unreachable ();
+    }
+}
+
+
+/* Worker function for TARGET_ASM_TRAMPOLINE_TEMPLATE.  */
+
+static void
+v810_asm_trampoline_template (FILE *f)
+{
+  fprintf (f, "\tmov r31,r20\n");
+  fprintf (f, "\tjal .+4\n");
+  fprintf (f, "\tmov r31,r12\n");
+  fprintf (f, "\tmov r20,r31\n");
+  fprintf (f, "\tld.w 14[r12],r20\n");
+  fprintf (f, "\tld.w 18[r12],r12\n");
+  fprintf (f, "\tjmp [r12]\n");
+  fprintf (f, "\t.long 0\n");
+  fprintf (f, "\t.long 0\n");
+}
+
+/* Worker function for TARGET_TRAMPOLINE_INIT.  */
+
+static void
+v810_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
+{
+  rtx mem, fnaddr = XEXP (DECL_RTL (fndecl), 0);
+
+  emit_block_move (m_tramp, assemble_trampoline_template (),
+                   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
+
+  mem = adjust_address (m_tramp, SImode, 20);
+  emit_move_insn (mem, chain_value);
+  mem = adjust_address (m_tramp, SImode, 24);
+  emit_move_insn (mem, fnaddr);
+}
+
+/* Implement TARGET_LEGITIMATE_CONSTANT_P.  */
+
+static bool
+v810_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  return (GET_CODE (x) == CONST_DOUBLE
+          || !(GET_CODE (x) == CONST
+               && GET_CODE (XEXP (x, 0)) == PLUS
+               && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
+               && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
+               && !CONST_OK_FOR_K (INTVAL (XEXP (XEXP (x, 0), 1)))));
+}
+
+static int
+v810_memory_move_cost (enum machine_mode mode,
+                       reg_class_t reg_class ATTRIBUTE_UNUSED,
+                       bool in)
+{
+  switch (GET_MODE_SIZE (mode))
+    {
+    case 0:
+      return in ? 24 : 8;
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+      return in ? 6 : 2;
+    default:
+      return (GET_MODE_SIZE (mode) / 2) * (in ? 3 : 1);
+    }
+}
+
+/* V810 specific attributes.  */
+
+static const struct attribute_spec v810_attribute_table[] =
+{
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
+       affects_type_identity } */
+  { "interrupt_handler", 0, 0, true,  false, false,
+    v810_handle_interrupt_attribute, false },
+  { "interrupt",         0, 0, true,  false, false,
+    v810_handle_interrupt_attribute, false },
+  { "sda",               0, 0, true,  false, false,
+    v810_handle_data_area_attribute, false },
+  { "tda",               0, 0, true,  false, false,
+    v810_handle_data_area_attribute, false },
+  { "zda",               0, 0, true,  false, false,
+    v810_handle_data_area_attribute, false },
+  { NULL,                0, 0, false, false, false, NULL, false }
+};
+
+/* Initialize the GCC target structure.  */
+
+#undef  TARGET_MEMORY_MOVE_COST
+#define TARGET_MEMORY_MOVE_COST v810_memory_move_cost
+
+#undef  TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\t.hword\t"
+
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND v810_print_operand
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS v810_print_operand_address
+#undef  TARGET_PRINT_OPERAND_PUNCT_VALID_P
+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P v810_print_operand_punct_valid_p
+
+#undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA
+#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA v810_output_addr_const_extra
+
+#undef  TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE v810_attribute_table
+
+#undef  TARGET_INSERT_ATTRIBUTES
+#define TARGET_INSERT_ATTRIBUTES v810_insert_attributes
+
+#undef  TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION  v810_select_section
+
+/* The assembler supports switchable .bss sections, but
+   v810_select_section doesn't yet make use of them.  */
+#undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS
+#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false
+
+#undef  TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO v810_encode_section_info
+
+#undef  TARGET_ASM_FILE_START_FILE_DIRECTIVE
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+
+#undef  TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS v810_rtx_costs
+
+#undef  TARGET_ADDRESS_COST
+#define TARGET_ADDRESS_COST hook_int_rtx_mode_as_bool_0
+
+#undef  TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P v810_function_value_regno_p
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE v810_function_value
+
+#undef  TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+
+#undef  TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY v810_return_in_memory
+
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE v810_pass_by_reference
+
+#undef  TARGET_CALLEE_COPIES
+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true
+
+#undef  TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES v810_arg_partial_bytes
+
+#undef  TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG v810_function_arg
+
+#undef  TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE v810_function_arg_advance
+
+#undef  TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED v810_frame_pointer_required
+
+#undef  TARGET_CAN_ELIMINATE
+#define TARGET_CAN_ELIMINATE v810_can_eliminate
+
+#undef  TARGET_ASM_TRAMPOLINE_TEMPLATE
+#define TARGET_ASM_TRAMPOLINE_TEMPLATE v810_asm_trampoline_template
+#undef  TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT v810_trampoline_init
+
+#undef  TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P v810_legitimate_constant_p
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-v810.h"
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810.h gcc-4.9.4/gcc/config/v810/v810.h
--- gcc-4.9.4-pure/gcc/config/v810/v810.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810.h	2022-03-03 10:28:51.191740300 -0500
@@ -0,0 +1,877 @@
+/* Definitions of target machine for GNU compiler. NEC V810 series
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+   Contributed by Jeff Law (law@cygnus.com).
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_V810_H
+#define GCC_V810_H
+
+extern GTY(()) rtx v810_compare_op0;
+extern GTY(()) rtx v810_compare_op1;
+
+#undef LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:--start-group -lc -lgcc --end-group}}"
+
+#undef ENDFILE_SPEC
+#undef LINK_SPEC
+#undef STARTFILE_SPEC
+#undef ASM_SPEC
+
+#define TARGET_CPU_generic 	1
+
+#ifndef TARGET_CPU_DEFAULT
+#define TARGET_CPU_DEFAULT	TARGET_CPU_generic
+#endif
+
+#define MASK_DEFAULT            MASK_V810
+#define SUBTARGET_ASM_SPEC 	"%{!mv*:-mv810}"
+#define SUBTARGET_CPP_SPEC 	"%{!mv*:-D__v810__}"
+
+#define ASM_SPEC "%{mv*:-mv%*}" \
+"%{mrelax:-mrelax}"
+
+#define CPP_SPEC "\
+  %{mv810:-D__v810__} \
+  %(subtarget_cpp_spec)"
+
+#define EXTRA_SPECS \
+ { "subtarget_asm_spec", SUBTARGET_ASM_SPEC }, \
+ { "subtarget_cpp_spec", SUBTARGET_CPP_SPEC } 
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define TARGET_CPU_CPP_BUILTINS() do {		\
+  builtin_define( "__v810" );			\
+  builtin_assert( "machine=v810" );		\
+  builtin_assert( "cpu=v810" );			\
+} while(0)
+
+#define MASK_CPU (MASK_V810)
+
+/* Target machine storage layout */
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.
+   This is not true on the NEC V810.  */
+#define BITS_BIG_ENDIAN         0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+/* This is not true on the NEC V810.  */
+#define BYTES_BIG_ENDIAN        0
+
+/* Define this if most significant word of a multiword number is lowest
+   numbered.
+   This is not true on the NEC V810.  */
+#define WORDS_BIG_ENDIAN        0
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD          4
+
+/* Define the size of `int'.  The default is the same as the word size.  */
+#define INT_TYPE_SIZE           32
+
+/* Define the size of `long'.  The default is the same as the word size.  */
+#define LONG_TYPE_SIZE          32
+
+/* Define the size of `long long'.  The default is the twice the word size.  */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* The V810 only supports single-precision floating point.  */
+#define WIDEST_HARDWARE_FP_SIZE 32
+
+/* Disable libgcc2 support for double-precision floating point.  */
+#define LIBGCC2_HAS_DF_MODE     0
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases,
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type.
+
+   Some simple experiments have shown that leaving UNSIGNEDP alone
+   generates the best overall code.  */
+
+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \
+  if (GET_MODE_CLASS (MODE) == MODE_INT \
+      && GET_MODE_SIZE (MODE) < 4)      \
+    { (MODE) = SImode; }
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY           32
+
+/* The stack goes in 32-bit lumps.  */
+#define STACK_BOUNDARY          32
+
+/* Allocation boundary (in *bits*) for the code of a function.
+   16 is the minimum boundary; 32 would give better performance.  */
+#define FUNCTION_BOUNDARY       (optimize_size ? 16 : 32)
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT       32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY    32
+
+/* No structure field wants to be aligned rounder than this.  */
+#define BIGGEST_FIELD_ALIGNMENT 32
+
+/* Define this if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT        1
+
+/* Define this as 1 if `char' should by default be signed; else as 0.
+
+   On the NEC V810, loads do sign extension, so make this default.  */
+#define DEFAULT_SIGNED_CHAR     1
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Standard register usage.  */
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.  */
+
+#define FIRST_PSEUDO_REGISTER 34
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.  */
+
+#define FIXED_REGISTERS \
+  { 1, 1, 1, 1, 1, 1, 0, 0, \
+    0, 0, 0, 0, 0, 0, 0, 0, \
+    0, 0, 0, 0, 0, 0, 0, 0, \
+    0, 0, 0, 0, 0, 0, 0, 0, \
+    1, 1 }
+
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you
+   like.  */
+
+#define CALL_USED_REGISTERS \
+  { 1, 1, 1, 1, 1, 1, 1, 1, \
+    1, 1, 1, 1, 1, 1, 1, 1, \
+    1, 1, 1, 1, 0, 0, 0, 0, \
+    0, 0, 0, 0, 0, 0, 1, 1, \
+    1, 1 }
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.
+
+   On the V810, we use the return registers first, then all of the volatile
+   registers, then the saved registers in reverse order to better save the
+   registers with an helper function, and finally the fixed registers.  */
+
+/* R30 is a scratch register on the V810, and so doesn't get saved in an
+   interrupt unless it's actually used. This is different to the V850.  */
+
+#define REG_ALLOC_ORDER                                            \
+{                                                                  \
+  10, 11,                                 /* return registers   */ \
+  12, 13, 14, 15, 16, 17, 18, 19, 30,     /* scratch registers  */ \
+   6,  7,  8,  9, 31,                     /* argument registers */ \
+  29, 28, 27, 26, 25, 24, 23, 22, 21, 20, /* saved registers    */ \
+   0,  1,  2,  3,  4,  5,                 /* fixed registers    */ \
+  32, 33                                  /* pseudo-regosters   */ \
+}
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.  */
+
+#define HARD_REGNO_NREGS(REGNO, MODE)   \
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode
+   MODE.  */
+
+#define HARD_REGNO_MODE_OK(REGNO, MODE) \
+ ((GET_MODE_SIZE (MODE) <= 4) || (((REGNO) & 1) == 0 && (REGNO) != 0))
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+
+#define MODES_TIEABLE_P(MODE1, MODE2) \
+  (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))
+
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+   
+enum reg_class
+{
+  NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.  */
+
+#define REG_CLASS_NAMES \
+{ "NO_REGS", "GENERAL_REGS", "ALL_REGS", "LIM_REGS" }
+
+/* Define which registers fit in which classes.
+   This is an initializer for a vector of HARD_REG_SET
+   of length N_REG_CLASSES.  */
+
+#define REG_CLASS_CONTENTS                     \
+{                                              \
+  { 0x00000000,0x0 }, /* NO_REGS      */       \
+  { 0xffffffff,0x0 }, /* GENERAL_REGS */       \
+  { 0xffffffff,0x0 }, /* ALL_REGS      */      \
+}
+
+/* The same information, inverted:
+   Return the class number of the smallest class containing
+   reg number REGNO.  This could be a conditional expression
+   or could index an array.  */
+
+#define REGNO_REG_CLASS(REGNO)  ((REGNO == CC_REGNUM) ? NO_REGS : GENERAL_REGS)
+
+/* The class value for index registers, and the one for base regs.  */
+
+#define INDEX_REG_CLASS NO_REGS
+#define BASE_REG_CLASS  GENERAL_REGS
+
+/* Macros to check register numbers against specific register classes.  */
+
+/* These assume that REGNO is a hard or pseudo reg number.
+   They give nonzero only if REGNO is a hard reg of the suitable class
+   or a pseudo reg currently allocated to a suitable hard reg.
+   Since they use reg_renumber, they are safe only once reg_renumber
+   has been allocated, which happens in reginfo.c during register
+   allocation.  */
+ 
+#define REGNO_OK_FOR_BASE_P(regno)             \
+  (((regno) < FIRST_PSEUDO_REGISTER            \
+    && (regno) != CC_REGNUM)                   \
+   || reg_renumber[regno] >= 0)
+
+#define REGNO_OK_FOR_INDEX_P(regno) 0
+
+/* Convenience wrappers around insn_const_int_ok_for_constraint.  */
+
+#define CONST_OK_FOR_I(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_I)
+#define CONST_OK_FOR_J(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_J)
+#define CONST_OK_FOR_K(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_K)
+#define CONST_OK_FOR_L(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_L)
+#define CONST_OK_FOR_M(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_M)
+#define CONST_OK_FOR_N(VALUE) \
+  insn_const_int_ok_for_constraint (VALUE, CONSTRAINT_N)
+
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this to nonzero if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.  */
+
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+
+#define STARTING_FRAME_OFFSET 0
+
+/* Offset from the argument pointer register to the first argument's address.
+   On some machines it may depend on the data type of the function.
+   If ARGS_GROW_DOWNWARD, this is the offset to the location above the first
+   argument's address. */
+
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* A C expression whose value is RTL representing the address in a stack frame
+   where the pointer to the caller's frame is stored.  Assume that FRAMEADDR is
+   an RTL expression for the address of the stack frame itself.
+
+   If you don't define this macro, the default is to return the value of
+   FRAMEADDR--that is, the stack frame address is also the address of the stack
+   word that points to the previous frame.  */
+
+/* Specify the registers used for certain standard purposes.
+   The values of these macros are register numbers.  */
+
+/* Register to use for pushing function arguments.  */
+
+#define STACK_POINTER_REGNUM SP_REGNUM
+
+/* Base register for access to local variables of the function.  */
+
+#define FRAME_POINTER_REGNUM FP_REGNUM
+
+/* Register containing return address from latest function call.  */
+
+#define LINK_POINTER_REGNUM LP_REGNUM
+     
+/* Base register for access to arguments of the function.  */
+
+#define ARG_POINTER_REGNUM 33
+
+/* Register in which static-chain is passed to a function.  */
+
+#define STATIC_CHAIN_REGNUM 20
+
+/* If defined, this macro specifies a table of register pairs used to
+   eliminate unneeded registers that point into the stack frame.  If
+   it is not defined, the only elimination attempted by the compiler
+   is to replace references to the frame pointer with references to
+   the stack pointer.
+
+   The definition of this macro is a list of structure
+   initializations, each of which specifies an original and
+   replacement register.
+
+   On some machines, the position of the argument pointer is not
+   known until the compilation is completed.  In such a case, a
+   separate hard register must be used for the argument pointer.
+   This register can be eliminated by replacing it with either the
+   frame pointer or the argument pointer, depending on whether or not
+   the frame pointer has been eliminated.
+
+   In this case, you might specify:
+        #define ELIMINABLE_REGS  \
+        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
+         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+   Note that the elimination of the argument pointer with the stack
+   pointer is specified first since that is the preferred elimination.  */
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },			\
+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM },			\
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}
+
+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It
+   specifies the initial difference between the specified pair of
+   registers.  This macro must be defined if `ELIMINABLE_REGS' is
+   defined.  */
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+  (OFFSET) = v810_initial_elimination_offset(FROM, TO)
+
+/* Keep the stack pointer constant throughout the function.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+#define RETURN_ADDR_RTX(COUNT, FP) v810_return_addr (COUNT)
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+
+#define CUMULATIVE_ARGS struct cum_arg
+struct cum_arg { int nbytes; int anonymous_args; };
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+  do { (CUM).nbytes = 0; } while (0)
+
+/* When a parameter is passed in a register, stack space is still
+   allocated for it.  */
+
+/* Define this macro if functions should assume that stack space has been
+   allocated for arguments even when their values are passed in registers.
+   The value of this macro is the size, in bytes, of the area reserved for
+   arguments passed in registers for the function represented by fndecl,
+   which can be zero if GCC is calling a library function. */
+/* #define REG_PARM_STACK_SPACE(DECL) 0 */
+
+/* 1 if N is a possible register number for function argument passing.  */
+
+#define FUNCTION_ARG_REGNO_P(N) (N >= 6 && N <= 9)
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+
+#define LIBCALL_VALUE(MODE) \
+  gen_rtx_REG (MODE, 10)
+
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.
+   No definition is equivalent to always zero.  */
+
+#define EXIT_IGNORE_STACK 1
+
+/* Define this macro as a C expression that is nonzero for registers
+   used by the epilogue or the `return' pattern.  */
+
+#define EPILOGUE_USES(REGNO) \
+  (reload_completed && (REGNO) == LINK_POINTER_REGNUM)
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+
+#define FUNCTION_PROFILER(FILE, LABELNO) ;
+
+/* Length in units of the trampoline for entering a nested function.  */
+
+#define TRAMPOLINE_SIZE 28
+
+/* Addressing modes, and classification of registers for them.  */
+
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+
+/* ??? This seems too exclusive.  May get better code by accepting more
+   possibilities here, in particular, should accept ZDA_NAME SYMBOL_REFs.  */
+
+#define CONSTANT_ADDRESS_P(X) constraint_satisfied_p (X, CONSTRAINT_K)
+
+/* Maximum number of registers that can appear in a valid memory address.  */
+
+#define MAX_REGS_PER_ADDRESS 1
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
+   and check its validity for a certain class.
+   We have two alternate definitions for each of them.
+   The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.
+   The symbol REG_OK_STRICT causes the latter definition to be used.
+
+   Most source files want to accept pseudo regs in the hope that
+   they will get allocated to the class that the insn wants them to be in.
+   Source files for reload pass need to be strict.
+   After reload, it makes no difference, since pseudo regs have
+   been eliminated by then.  */
+
+#ifndef REG_OK_STRICT
+
+/* Nonzero if X is a hard reg that can be used as an index
+   or if it is a pseudo reg.  */
+#define REG_OK_FOR_INDEX_P(X) 0
+/* Nonzero if X is a hard reg that can be used as a base reg
+   or if it is a pseudo reg.  */
+#define REG_OK_FOR_BASE_P(X) 1
+#define REG_OK_FOR_INDEX_P_STRICT(X) 0
+#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))
+#define STRICT 0
+
+#else
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#define REG_OK_FOR_INDEX_P(X) 0
+/* Nonzero if X is a hard reg that can be used as a base reg.  */
+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))
+#define STRICT 1
+
+#endif
+
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address.
+
+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,
+   except for CONSTANT_ADDRESS_P which is actually
+   machine-independent.  */
+
+/* Accept either REG or SUBREG where a register is valid.  */
+  
+#define RTX_OK_FOR_BASE_P(X)						\
+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))					\
+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))			\
+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))
+
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
+do {									\
+  if (RTX_OK_FOR_BASE_P (X)) 						\
+    goto ADDR;								\
+  if (CONSTANT_ADDRESS_P (X)						\
+      && (MODE == QImode || INTVAL (X) % 2 == 0)			\
+      && (GET_MODE_SIZE (MODE) <= 4 || INTVAL (X) % 4 == 0))		\
+    goto ADDR;								\
+  if (GET_CODE (X) == LO_SUM						\
+      && REG_P (XEXP (X, 0))						\
+      && REG_OK_FOR_BASE_P (XEXP (X, 0))				\
+      && CONSTANT_P (XEXP (X, 1))					\
+      && (GET_CODE (XEXP (X, 1)) != CONST_INT				\
+	  || ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)		\
+	      && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)))))		\
+      && GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode))		\
+    goto ADDR;								\
+  if (special_symbolref_operand (X, MODE)				\
+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode)))		\
+     goto ADDR;								\
+  if (GET_CODE (X) == PLUS						\
+      && RTX_OK_FOR_BASE_P (XEXP (X, 0)) 				\
+      && constraint_satisfied_p (XEXP (X,1), CONSTRAINT_K)		\
+      && ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)		\
+	   && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)) 			\
+                              + (GET_MODE_NUNITS (MODE) * UNITS_PER_WORD)))) \
+    goto ADDR;			\
+} while (0)
+
+
+/* Tell final.c how to eliminate redundant test instructions.  */
+
+/* Here we define machine-dependent flags and fields in cc_status
+   (see `conditions.h').  No extra ones are needed for the VAX.  */
+
+/* Store in cc_status the expressions
+   that the condition codes will describe
+   after execution of an instruction whose pattern is EXP.
+   Do not alter them if the instruction would not alter the cc's.  */
+
+#define CC_OVERFLOW_UNUSABLE 0x200
+#define CC_NO_CARRY CC_NO_OVERFLOW
+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)
+
+/* Nonzero if access to memory by bytes or half words is no faster
+   than accessing full words.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* According expr.c, a value of around 6 should minimize code size, and
+   for the V810 series, that's our primary concern.  */
+#define MOVE_RATIO(speed) 6
+
+/* Indirect calls are expensive, never turn a direct call
+   into an indirect call.  */
+#define NO_FUNCTION_CSE
+
+/* The four different data regions on the v810.  */
+typedef enum 
+{
+  DATA_AREA_NORMAL,
+  DATA_AREA_SDA,
+  DATA_AREA_TDA,
+  DATA_AREA_ZDA
+} v810_data_area;
+
+#define TEXT_SECTION_ASM_OP  "\t.section .text"
+#define DATA_SECTION_ASM_OP  "\t.section .data"
+#define BSS_SECTION_ASM_OP   "\t.section .bss"
+#define SDATA_SECTION_ASM_OP "\t.section .sdata,\"aw\""
+#define SBSS_SECTION_ASM_OP  "\t.section .sbss,\"aw\""
+
+#define SCOMMON_ASM_OP 	       "\t.scomm\t"
+#define ZCOMMON_ASM_OP 	       "\t.zcomm\t"
+#define TCOMMON_ASM_OP 	       "\t.tcomm\t"
+
+#define ASM_COMMENT_START "#"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+
+#define ASM_APP_ON "#APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef  USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX "_"
+
+/* This says how to output the assembler to define a global
+   uninitialized but not common symbol.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
+
+#undef  ASM_OUTPUT_ALIGNED_BSS 
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  v810_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* This says how to output the assembler to define a global
+   uninitialized, common symbol.  */
+#undef  ASM_OUTPUT_ALIGNED_COMMON
+#undef  ASM_OUTPUT_COMMON
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \
+     v810_output_common (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* This says how to output the assembler to define a local
+   uninitialized symbol.  */
+#undef  ASM_OUTPUT_ALIGNED_LOCAL
+#undef  ASM_OUTPUT_LOCAL
+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \
+     v810_output_local (FILE, DECL, NAME, SIZE, ALIGN)
+     
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global "
+
+#define ASM_PN_FORMAT "%s___%lu"
+
+/* This is how we tell the assembler that two symbols have the same value.  */
+
+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \
+  do { assemble_name(FILE, NAME1); 	 \
+       fputs(" = ", FILE);		 \
+       assemble_name(FILE, NAME2);	 \
+       fputc('\n', FILE); } while (0)
+
+
+/* How to refer to registers in assembler output.
+   This sequence is indexed by compiler's hard-register-number (see above).  */
+
+#define REGISTER_NAMES                                         \
+{  "r0",  "r1",  "fp",  "sp",  "gp",  "tp",  "r6" , "r7",      \
+   "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15",      \
+  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",      \
+  "r24", "r25", "r26", "r27", "r28", "r29", "r30",  "lp",      \
+  "psw", ".ap"}
+
+/* Register numbers */
+
+#define ADDITIONAL_REGISTER_NAMES              \
+{ { "zero",    ZERO_REGNUM },                  \
+  { "r2",      2 },                            \
+  { "r3",      3 },                            \
+  { "r4",      4 },                            \
+  { "r5",      5 },                            \
+  { "r31",     LP_REGNUM} }
+
+/* This is how to output an element of a case-vector that is absolute.  */
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  fprintf (FILE, "\t%s .L%d\n",					\
+	   (TARGET_BIG_SWITCH ? ".long" : ".short"), VALUE)
+
+/* This is how to output an element of a case-vector that is relative.  */
+
+/* Disable the shift, which is for the currently disabled "switch"
+   opcode.  Se casesi in v810.md.  */
+
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) 		\
+  fprintf (FILE, "\t%s .L%d-.L%d\n",				\
+	   (TARGET_BIG_SWITCH ? ".long" : ".short"),			\
+	   VALUE, REL)
+
+#define ASM_OUTPUT_ALIGN(FILE, LOG)	\
+  if ((LOG) != 0)			\
+    fprintf (FILE, "\t.align %d\n", (LOG))
+
+/* We don't have to worry about dbx compatibility for the v810.  */
+#define DEFAULT_GDB_EXTENSIONS 1
+
+/* Use dwarf2 debugging info by default.  */
+#undef  PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE   DWARF2_DEBUG
+
+#define DWARF2_FRAME_INFO          1
+#define DWARF2_UNWIND_INFO         0
+#define INCOMING_RETURN_ADDR_RTX   gen_rtx_REG (Pmode, LINK_POINTER_REGNUM)
+#define DWARF_FRAME_RETURN_COLUMN  DWARF_FRAME_REGNUM (LINK_POINTER_REGNUM)
+
+#ifndef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \
+  sprintf (STRING, "*.%s%u", PREFIX, (unsigned int)(NUM))
+#endif
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? SImode : HImode)
+
+/* Define as C expression which evaluates to nonzero if the tablejump
+   instruction expects the table to contain offsets from the address of the
+   table.
+   Do not define this if the table should contain absolute addresses.  */
+#define CASE_VECTOR_PC_RELATIVE 1
+
+/* The switch instruction requires that the jump table immediately follow
+   it.  */
+#define JUMP_TABLES_IN_TEXT_SECTION (!TARGET_JUMP_TABLES_IN_DATA_SECTION)
+
+#undef ASM_OUTPUT_BEFORE_CASE_LABEL
+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \
+  ASM_OUTPUT_ALIGN ((FILE), (TARGET_BIG_SWITCH ? 2 : 1));
+
+#define WORD_REGISTER_OPERATIONS
+
+/* Byte and short loads sign extend the value to a word.  */
+#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND
+
+/* Max number of bytes we can move from memory to memory
+   in one reasonably fast instruction.  */
+#define MOVE_MAX	4
+
+/* Define if shifts truncate the shift count
+   which implies one can omit a sign-extension or zero-extension
+   of a shift count.  */
+#define SHIFT_COUNT_TRUNCATED 1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* A function address in a call instruction
+   is a byte address (for indexing purposes)
+   so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE QImode
+
+/* Tell compiler we want to support GHS pragmas */
+#define REGISTER_TARGET_PRAGMAS() do {				\
+  c_register_pragma ("ghs", "interrupt", ghs_pragma_interrupt);	\
+  c_register_pragma ("ghs", "section",   ghs_pragma_section);	\
+  c_register_pragma ("ghs", "starttda",  ghs_pragma_starttda);	\
+  c_register_pragma ("ghs", "startsda",  ghs_pragma_startsda);	\
+  c_register_pragma ("ghs", "startzda",  ghs_pragma_startzda);	\
+  c_register_pragma ("ghs", "endtda",    ghs_pragma_endtda);	\
+  c_register_pragma ("ghs", "endsda",    ghs_pragma_endsda);	\
+  c_register_pragma ("ghs", "endzda",    ghs_pragma_endzda);	\
+} while (0)
+
+/* enum GHS_SECTION_KIND is an enumeration of the kinds of sections that
+   can appear in the "ghs section" pragma.  These names are used to index
+   into the GHS_default_section_names[] and GHS_current_section_names[]
+   that are defined in v810.c, and so the ordering of each must remain
+   consistent. 
+
+   These arrays give the default and current names for each kind of 
+   section defined by the GHS pragmas.  The current names can be changed
+   by the "ghs section" pragma.  If the current names are null, use 
+   the default names.  Note that the two arrays have different types.
+
+   For the *normal* section kinds (like .data, .text, etc.) we do not
+   want to explicitly force the name of these sections, but would rather
+   let the linker (or at least the back end) choose the name of the 
+   section, UNLESS the user has force a specific name for these section
+   kinds.  To accomplish this set the name in ghs_default_section_names
+   to null.  */
+
+enum GHS_section_kind
+{ 
+  GHS_SECTION_KIND_DEFAULT,
+
+  GHS_SECTION_KIND_TEXT,
+  GHS_SECTION_KIND_DATA, 
+  GHS_SECTION_KIND_RODATA,
+  GHS_SECTION_KIND_BSS,
+  GHS_SECTION_KIND_SDATA,
+  GHS_SECTION_KIND_ROSDATA,
+  GHS_SECTION_KIND_TDATA,
+  GHS_SECTION_KIND_ZDATA,
+  GHS_SECTION_KIND_ROZDATA,
+
+  COUNT_OF_GHS_SECTION_KINDS  /* must be last */
+};
+
+/* The following code is for handling pragmas supported by the
+   v810 compiler produced by Green Hills Software.  This is at
+   the specific request of a customer.  */
+
+typedef struct data_area_stack_element
+{
+  struct data_area_stack_element * prev;
+  v810_data_area                   data_area; /* Current default data area.  */
+} data_area_stack_element;
+
+/* Track the current data area set by the
+   data area pragma (which can be nested).  */
+extern data_area_stack_element * data_area_stack;
+
+/* Names of the various data areas used on the v810.  */
+extern tree GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];
+extern tree GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];
+
+/* The assembler op to start the file.  */
+
+#define FILE_ASM_OP "\t.file\n"
+
+/* Implement ZDA and SDA */
+
+#define SYMBOL_FLAG_ZDA		(SYMBOL_FLAG_MACH_DEP << 0)
+#define SYMBOL_FLAG_TDA		(SYMBOL_FLAG_MACH_DEP << 1)
+#define SYMBOL_FLAG_SDA		(SYMBOL_FLAG_MACH_DEP << 2)
+#define SYMBOL_REF_ZDA_P(X)	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ZDA) != 0)
+#define SYMBOL_REF_TDA_P(X)	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_TDA) != 0)
+#define SYMBOL_REF_SDA_P(X)	((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_SDA) != 0)
+
+#define TARGET_ASM_INIT_SECTIONS v810_asm_init_sections
+
+/* Define this so that the cc1plus will not think that system header files
+   need an implicit 'extern "C" { ... }' assumed.  This breaks testing C++
+   in a build directory where the libstdc++ header files are found via a
+   -isystem <path-to-build-dir>.  */
+#define NO_IMPLICIT_EXTERN_C
+
+#endif /* ! GCC_V810_H */
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810.md gcc-4.9.4/gcc/config/v810/v810.md
--- gcc-4.9.4-pure/gcc/config/v810/v810.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810.md	2022-03-07 17:07:56.035551700 -0500
@@ -0,0 +1,1195 @@
+;; GCC machine description for NEC V810
+;; Copyright (C) 1996-2014 Free Software Foundation, Inc.
+;; Contributed by Jeff Law (law@cygnus.com).
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; The original PO technology requires these to be ordered by speed,
+;; so that assigner will pick the fastest.
+
+;; See file "rtl.def" for documentation on define_insn, match_*, et. al.
+
+;; The size of instructions in bytes.
+
+;;---------------------------------------------------------------------------
+;; Constants
+
+;;
+(define_constants
+  [(ZERO_REGNUM  0) ; constant zero
+   (FP_REGNUM    2) ; Frame Pointer  (was unused Handler Stack Pointer)
+   (SP_REGNUM    3) ; Stack Pointer
+   (GP_REGNUM    4) ; GP Pointer
+   (TP_REGNUM    5) ; Thread Pointer (was unused Text Pointer)
+   (LP_REGNUM   31) ; Return address register
+   (CC_REGNUM   32) ; Condition code pseudo register
+   (AP_PSEUDO   33) ; Argument Pointer pseudo register
+  ]
+)
+
+(define_attr "length" ""
+  (const_int 4))
+
+;; Types of instructions (for scheduling purposes).
+;;
+;; "other" = unconditional branch, preserves cc.
+;; "move"  = move, preserves cc.
+;; "load"  = load from memory, preserves cc.
+;; "store" = save into memory, preserves cc.
+;; "usecc" = conditional branch and setf, preserves cc.
+;; "setcc" = integer math, sets cc.
+;; "cmpcc" = compare and set cc.
+;; "float" = floating point, sets cc.
+
+(define_attr "type" "other,move,load,store,usecc,setcc,cmpcc,float"
+  (const_string "other"))
+
+(define_attr "cpu" "none,v810"
+  (cond [(match_test "TARGET_V810")
+       (const_string "v810")]
+       (const_string "none")))
+
+;; Condition code settings.
+;; none - insn does not affect cc
+;; none_0hit - insn does not affect cc but it does modify operand 0
+;;	This attribute is used to keep track of when operand 0 changes.
+;; 	See the description of NOTICE_UPDATE_CC for more info.
+;; set_znv - sets z,n,v to usable values; c is unknown.
+;; set_zn  - sets z,n to usable values; v,c is unknown.
+;; compare - compare instruction
+;; clobber - value of cc is unknown
+
+(define_attr "cc" "none,none_0hit,set_zn,set_znv,compare,clobber"
+  (const_string "clobber"))
+
+;; // JCB - Old-Style pipeline description from Japanese GCC 2.95 ...
+;; // ... for V850 ...
+;; // -(define_function_unit "memory" 1 0 (eq_attr "type" "load") 2 0)
+;; // -(define_function_unit "mult"   1 0 (eq_attr "type" "mult") 2 0)
+;; // ... for V810 ...
+;; // +(define_function_unit "mem" 1 0 (eq_attr "type" "load") 2 0)
+;; // +(define_function_unit "mem" 1 0 (eq_attr "type" "store") 1 2 [(eq_attr "type" "load")])
+;; // +(define_function_unit "ex" 1 0 (eq_attr "type" "mul") 12 12)
+;; // +(define_function_unit "ex" 1 0 (eq_attr "type" "div") 37 37)
+;; // +(define_function_unit "ex" 1 0 (eq_attr "type" "udiv") 35 35)
+
+;; JCB 2022-02-15: Pipeline description for the instruction scheduler.
+;;
+;; The V810 pipeline hazards are very different to the V850 hazards!
+;;
+;; The V810 Architecture Manual does not describe the CPU's pipeline
+;; operation, but the V830 Architecture Manual has a full description
+;; of its pipeline, which includes similar hazards to those described
+;; in NEC's Seminar to VirtualBoy developers.
+;;
+;; Importantly, there is no hazard for using a using a register that
+;; was modified in the previous instruction, except as the base addr
+;; in a load/store!
+;;
+;; There are hazards for ...
+;;
+;; a) Changing a register and then using it as the base in a load/store.
+;; b) Changing the CC and then doing a SETF or Bcond.
+;; c) ST follow by an LD is very bad!
+;; d) LD/LD is very good, but ST/ST has a 2-deep write buffer and benefits
+;;    from distance between the ST instructions.
+;;
+;; Testing indicates that the "default_latency" values given *seems* to
+;; signify the number of instructions to add before an instruction that
+;; uses the result.
+;;
+;; Thus a value of "0" seems to indicate that no delay is needed.
+;;
+;; Note that we *cannot* separate setcc from usecc while still using cc0
+;; mode, which the v850 also continues to use until GCC9.
+;;
+;; Backporting the GCC9 CCmode changes works, but it breaks the detection
+;; of flags set by add/sub/and/not/... and so isn't worth it.
+;;
+;; See https://gcc.gnu.org/wiki/CC0Transition
+;; See https://gcc.gnu.org/onlinedocs/gcc-4.9.4/gccint/CC0-Condition-Codes.html
+
+(define_insn_reservation "v810_other" 0
+  (eq_attr "type" "other")
+  "nothing")
+
+(define_insn_reservation "v810_usecc" 0
+  (eq_attr "type" "usecc")
+  "nothing")
+
+(define_insn_reservation "v810_setcc" 0
+  (eq_attr "type" "setcc,cmpcc,float")
+  "nothing")
+
+(define_insn_reservation "v810_move" 0
+  (eq_attr "type" "move")
+  "nothing")
+
+(define_insn_reservation "v810_load" 0
+  (eq_attr "type" "load")
+  "nothing")
+
+(define_insn_reservation "v810_store" 0
+  (eq_attr "type" "store")
+  "nothing")
+
+;; Attempt to separate setting and using a base address.
+
+(define_bypass 0 "v810_setcc,v810_move,v810_load" "v810_load,v810_store" "store_data_bypass_p")
+(define_bypass 3 "v810_setcc,v810_move,v810_load" "v810_load,v810_store")
+
+;; Attempt to separate setting and using condition codes.
+;;
+;; (define_bypass 3 "v810_setcc" "v810_usecc")
+
+(include "predicates.md")
+(include "constraints.md")
+
+;; ----------------------------------------------------------------------
+;; MOVE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  {
+    /* One of the ops has to be in a register or 0 */
+    if (!register_operand (operand0, QImode)
+	&& !reg_or_0_operand (operand1, QImode))
+      operands[1] = copy_to_mode_reg (QImode, operand1);
+  })
+
+(define_insn "*movqi_internal"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,r,m,m")
+	(match_operand:QI 1 "general_operand" "Jr,n,m,r,I"))]
+  "register_operand (operands[0], QImode)
+   || reg_or_0_operand (operands[1], QImode)"
+{
+  return output_move_single (operands);
+}
+  [(set_attr "length" "2,4,4,4,4")
+   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
+   (set_attr "type" "move,move,load,store,store")])
+
+;; movhi
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+{
+  /* One of the ops has to be in a register or 0 */
+  if (!register_operand (operand0, HImode)
+      && !reg_or_0_operand (operand1, HImode))
+    operands[1] = copy_to_mode_reg (HImode, operand1);
+})
+
+(define_insn "*movhi_internal"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m,m")
+	(match_operand:HI 1 "general_operand" "Jr,n,m,r,I"))]
+  "register_operand (operands[0], HImode)
+   || reg_or_0_operand (operands[1], HImode)"
+{
+  return output_move_single (operands);
+}
+  [(set_attr "length" "2,4,4,4,4")
+   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
+   (set_attr "type" "move,move,load,store,store")])
+
+;; movsi and helpers
+
+(define_insn "*movsi_high"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(high:SI (match_operand 1 "immediate_operand" "i")))]
+  ""
+  "movhi hi(%1),%.,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none_0hit")
+   (set_attr "type" "move")])
+
+(define_insn "*movsi_lo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		   (match_operand:SI 2 "immediate_operand" "i")))]
+  ""
+  "movea lo(%2),%1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none_0hit")
+   (set_attr "type" "move")])
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  ""
+  {
+    /* One of the ops has to be in a register or 0 */
+    if (!register_operand (operand0, SImode)
+	&& !reg_or_0_operand (operand1, SImode))
+      operands[1] = copy_to_mode_reg (SImode, operand1);
+
+    /* Some constants, as well as symbolic operands
+       must be done with HIGH & LO_SUM patterns.  */
+    if (CONSTANT_P (operands[1])	
+	&& GET_CODE (operands[1]) != HIGH
+	&& !special_symbolref_operand (operands[1], VOIDmode)
+	&& !(GET_CODE (operands[1]) == CONST_INT
+	     && (CONST_OK_FOR_J (INTVAL (operands[1]))
+		 || CONST_OK_FOR_K (INTVAL (operands[1]))
+		 || CONST_OK_FOR_L (INTVAL (operands[1])))))
+      {
+	rtx temp;
+
+	if (reload_in_progress || reload_completed)
+          temp = operands[0];
+	else
+	  temp = gen_reg_rtx (SImode);
+
+	emit_insn (gen_rtx_SET (SImode, temp,
+				gen_rtx_HIGH (SImode, operand1)));
+	emit_insn (gen_rtx_SET (SImode, operand0,
+				gen_rtx_LO_SUM (SImode, temp, operand1)));
+	DONE;
+      }
+  })
+
+;; ??? This always loads addresses using hilo.  If the only use of this address
+;; was in a load/store, then we would get smaller code if we only loaded the
+;; upper part with hi, and then put the lower part in the load/store insn.
+
+(define_insn "*movsi_internal"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,r,m,m")
+	(match_operand:SI 1 "movsi_source_operand" "Jr,K,L,m,R,r,I"))]
+  "register_operand (operands[0], SImode)
+   || reg_or_0_operand (operands[1], SImode)"
+{
+  return output_move_single (operands);
+}
+  [(set_attr "length" "2,4,4,4,4,4,4")
+   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
+   (set_attr "type" "move,move,move,load,move,store,store")])
+
+(define_insn "*movsf_internal"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,r,r,r,m,m,r")
+	(match_operand:SF 1 "general_operand" "Jr,K,L,n,m,r,IG,iF"))]
+  "register_operand (operands[0], SFmode)
+   || reg_or_0_operand (operands[1], SFmode)"
+{
+  return output_move_single (operands);
+}
+  [(set_attr "length" "2,4,4,8,4,4,4,8")
+   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
+   (set_attr "type" "move,move,move,move,load,store,store,move")])
+
+;; ----------------------------------------------------------------------
+;; TEST INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "cbranchsi4"
+  [(set (cc0)
+	(compare (match_operand:SI 1 "register_operand" "")
+		 (match_operand:SI 2 "reg_or_int5_operand" "")))
+   (set (pc)
+	(if_then_else
+	      (match_operator 0 "ordered_comparison_operator" [(cc0)
+							       (const_int 0)])
+              (label_ref (match_operand 3 "" ""))
+              (pc)))]
+ "")
+
+(define_expand "cstoresi4"
+  [(set (cc0)
+	(compare (match_operand:SI 2 "register_operand" "")
+		 (match_operand:SI 3 "reg_or_int5_operand" "")))
+   (set (match_operand:SI 0 "register_operand")
+        (match_operator:SI 1 "ordered_comparison_operator" [(cc0)
+							    (const_int 0)]))]
+  "")
+
+(define_expand "cmpsi"
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "r,r")
+		 (match_operand:SI 1 "reg_or_int5_operand" "r,J")))]
+   ""
+  {
+    v810_compare_op0 = operands[0];
+    v810_compare_op1 = operands[1];
+    DONE;
+  })
+
+(define_insn "cmpsi_insn"
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "r,r")
+		 (match_operand:SI 1 "reg_or_int5_operand" "r,J")))]
+  ""
+  "@
+  cmp %1,%0
+  cmp %1,%0"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "compare,compare")
+   (set_attr "type" "cmpcc,cmpcc")])
+
+(define_expand "cmpsf"
+  [(set (cc0)
+	(compare (match_operand:SF 0 "register_operand" "r")
+		 (match_operand:SF 1 "register_operand" "r")))]
+  ""
+  {
+    v810_compare_op0 = operands[0];
+    v810_compare_op1 = operands[1];
+    DONE;
+  })
+
+(define_insn "cmpsf_insn"
+  [(set (cc0)
+	(compare (match_operand:SF 0 "register_operand" "r")
+		 (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_V810"
+  "cmpf.s %1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "compare")
+   (set_attr "type" "cmpcc")])
+
+;; ----------------------------------------------------------------------
+;; ADD INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(plus:SI (match_operand:SI 1 "register_operand" "%0,r,r")
+		 (match_operand:SI 2 "nonmemory_operand" "rJ,K,U")))
+   (clobber (reg:CC CC_REGNUM))]
+
+  ""
+  "@
+   add %2,%0
+   addi %2,%1,%0
+   addi %O2(%P2),%1,%0"
+  [(set_attr "length" "2,4,4")
+   (set_attr "cc" "set_zn,set_zn,set_zn")
+   (set_attr "type" "setcc,setcc,setcc")])
+
+;; ----------------------------------------------------------------------
+;; SUBTRACT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(minus:SI (match_operand:SI 1 "register_operand" "0")
+		  (match_operand:SI 2 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "sub %2,%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (neg:SI (match_operand:SI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "not %1,%0 ; add 1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+;; ----------------------------------------------------------------------
+;; MULTIPLY INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (match_operand:SI 1 "register_operand" "%0")
+		 (match_operand:SI 2 "nonmemory_operand" "r")))
+   (clobber (reg:SI 30))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "mul %2,%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+;; ----------------------------------------------------------------------
+;; DIVIDE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "divmodsi4"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(div:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))
+   (set (match_operand:SI 3 "register_operand" "=r")
+	(mod:SI (match_dup 1)
+		(match_dup 2)))
+   (clobber (reg:SI 30))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "div %2,%0\;mov r30,%3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+(define_insn "divsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(div:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))
+   (clobber (reg:SI 30))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "div %2,%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+(define_insn "udivmodsi4"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(udiv:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))
+   (set (match_operand:SI 3 "register_operand" "=r")
+	(umod:SI (match_dup 1)
+		(match_dup 2)))
+   (clobber (reg:SI 30))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "divu %2,%0\;mov r30,%3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(udiv:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))
+   (clobber (reg:SI 30))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "divu %2,%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+
+;; ----------------------------------------------------------------------
+;; AND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(and:SI (match_operand:SI 1 "register_operand" "%0,0,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  and %2,%0
+  and %.,%0
+  andi %2,%1,%0"
+  [(set_attr "length" "2,2,4")
+   (set_attr "cc" "set_zn,set_zn,set_zn")
+   (set_attr "type" "setcc,setcc,setcc")])
+
+;; ----------------------------------------------------------------------
+;; OR INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "%0,0,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  or %2,%0
+  or %.,%0
+  ori %2,%1,%0"
+  [(set_attr "length" "2,2,4")
+   (set_attr "cc" "set_zn,set_zn,set_zn")
+   (set_attr "type" "setcc,setcc,setcc")])
+
+;; ----------------------------------------------------------------------
+;; XOR INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "%0,0,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  xor %2,%0
+  xor %.,%0
+  xori %2,%1,%0"
+  [(set_attr "length" "2,2,4")
+   (set_attr "cc" "set_zn,set_zn,set_zn")
+   (set_attr "type" "setcc,setcc,setcc")])
+
+;; ----------------------------------------------------------------------
+;; NOT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(not:SI (match_operand:SI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "not %1,%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+;; -----------------------------------------------------------------
+;; BIT FIELDS
+;; -----------------------------------------------------------------
+
+;; ??? Is it worth defining insv and extv for the V810 series?!?
+
+;; An insv pattern would be useful, but does not get used because
+;; store_bit_field never calls insv when storing a constant value into a
+;; single-bit bitfield.
+
+;; extv/extzv patterns would be useful, but do not get used because
+;; optimize_bitfield_compare in fold-const usually converts single
+;; bit extracts into an AND with a mask.
+
+;; -----------------------------------------------------------------
+;; Scc INSTRUCTIONS
+;; -----------------------------------------------------------------
+
+(define_insn "*setcc"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (match_operator:SI 1 "comparison_operator"
+	 [(cc0) (const_int 0)]))]
+  ""
+{
+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
+      && (GET_CODE (operands[1]) == GT
+	  || GET_CODE (operands[1]) == GE
+	  || GET_CODE (operands[1]) == LE
+	  || GET_CODE (operands[1]) == LT))
+    return 0;
+
+  return \"setf %c1,%0\";
+}
+  [(set_attr "length" "4")
+   (set_attr "cc" "none_0hit")
+   (set_attr "type" "usecc")])
+
+(define_insn "setf_insn"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "comparison_operator"
+                          [(reg:CC CC_REGNUM) (const_int 0)]))]
+  ""
+  "setf %b1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none_0hit")
+   (set_attr "type" "usecc")])
+
+;; ----------------------------------------------------------------------
+;; CONDITIONAL MOVE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; ---------------------------------------------------------------------
+;; BYTE SWAP INSTRUCTIONS
+;; ---------------------------------------------------------------------
+
+;; ----------------------------------------------------------------------
+;; JUMP INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; Conditional jump instructions
+
+(define_insn "*branch_normal"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+				      [(cc0) (const_int 0)])
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+{
+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
+      && (GET_CODE (operands[1]) == GT
+	  || GET_CODE (operands[1]) == GE
+	  || GET_CODE (operands[1]) == LE
+	  || GET_CODE (operands[1]) == LT))
+    return 0;
+
+  if (get_attr_length (insn) == 2)
+    return \"b%b1 %l0\";
+  else
+    return \"b%B1 .+6 ; jr %l0\";
+}
+  [(set (attr "length")
+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
+		      (const_int 256))
+		  (const_int 2)
+		  (const_int 6)))
+   (set_attr "cc" "none")
+   (set_attr "type" "usecc")])
+
+(define_insn "*branch_invert"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+				      [(cc0) (const_int 0)])
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+{
+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
+      && (GET_CODE (operands[1]) == GT
+	  || GET_CODE (operands[1]) == GE
+	  || GET_CODE (operands[1]) == LE
+	  || GET_CODE (operands[1]) == LT))
+    return 0;
+
+  if (get_attr_length (insn) == 2)
+    return \"b%B1 %l0\";
+  else
+    return \"b%b1 .+6 ; jr %l0\";
+}
+  [(set (attr "length")
+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
+		      (const_int 256))
+		  (const_int 2)
+		  (const_int 6)))
+   (set_attr "cc" "none")
+   (set_attr "type" "usecc")])
+
+;; Unconditional and other jump instructions.
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+{
+ if (get_attr_length (insn) == 2)
+    return \"br %0\";
+  else
+    return \"jr %0\";
+}
+  [(set (attr "length")
+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
+		      (const_int 256))
+		  (const_int 2)
+		  (const_int 4)))
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jmp %0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+(define_insn "tablejump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jmp  %0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+(define_expand "casesi"
+  [(match_operand:SI 0 "register_operand" "")
+   (match_operand:SI 1 "register_operand" "")
+   (match_operand:SI 2 "register_operand" "")
+   (match_operand 3 "" "") (match_operand 4 "" "")]
+  ""
+  {
+    rtx reg = gen_reg_rtx (SImode);
+    rtx tableaddress = gen_reg_rtx (SImode);
+    rtx test;
+    rtx mem;
+
+    /* Subtract the lower bound from the index.  */
+    emit_insn (gen_subsi3 (reg, operands[0], operands[1]));
+
+    /* Compare the result against the number of table entries;
+       branch to the default label if out of range of the table.  */
+    test = gen_rtx_fmt_ee (GTU, VOIDmode, reg, operands[2]);
+    emit_jump_insn (gen_cbranchsi4 (test, reg, operands[2], operands[4]));
+
+    /* Shift index for the table array access.  */
+    emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));
+    /* Load the table address into a pseudo.  */
+    emit_insn (gen_movsi (tableaddress,
+  			gen_rtx_LABEL_REF (Pmode, operands[3])));
+    /* Add the table address to the index.  */
+    emit_insn (gen_addsi3 (reg, reg, tableaddress));
+    /* Load the table entry.  */
+    mem = gen_const_mem (CASE_VECTOR_MODE, reg);
+    if (! TARGET_BIG_SWITCH)
+      {
+        rtx reg2 = gen_reg_rtx (HImode);
+        emit_insn (gen_movhi (reg2, mem));
+        emit_insn (gen_extendhisi2 (reg, reg2));
+      }
+    else
+      emit_insn (gen_movsi (reg, mem));
+    /* Add the table address.  */
+    emit_insn (gen_addsi3 (reg, reg, tableaddress));
+    /* Branch to the switch label.  */
+    emit_jump_insn (gen_tablejump (reg, operands[3]));
+    DONE;
+  })
+
+;; Call subroutine with no return value.
+
+(define_expand "call"
+  [(call (match_operand:SI 0 "general_operand" "")
+	 (match_operand:SI 1 "general_operand" ""))]
+  ""
+  {
+    if (! call_address_operand (XEXP (operands[0], 0), SImode))
+      XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));
+    emit_call_insn (gen_call_internal_short (XEXP (operands[0], 0), operands[1]));
+
+    DONE;
+  })
+
+(define_insn "call_internal_short"
+  [(call (mem:SI (match_operand:SI 0 "call_address_operand" "S,r"))
+	 (match_operand:SI 1 "general_operand" "g,g"))
+   (clobber (reg:SI 31))]
+  ""
+  "@
+  jal %0
+  jal .+4 ; add 4,r31 ; jmp %0"
+  [(set_attr "length" "4,8")
+   (set_attr "cc" "clobber,clobber")
+   (set_attr "type" "other,other")]
+)
+
+;; Call subroutine, returning value in operand 0
+;; (which must be a hard register).
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+	(call (match_operand:SI 1 "general_operand" "")
+	      (match_operand:SI 2 "general_operand" "")))]
+  ""
+  {
+    if (! call_address_operand (XEXP (operands[1], 0), SImode))
+      XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));
+    emit_call_insn (gen_call_value_internal_short (operands[0],
+	 					   XEXP (operands[1], 0),
+						   operands[2]));
+    DONE;
+})
+
+(define_insn "call_value_internal_short"
+  [(set (match_operand 0 "" "=r,r")
+	(call (mem:SI (match_operand:SI 1 "call_address_operand" "S,r"))
+	      (match_operand:SI 2 "general_operand" "g,g")))
+   (clobber (reg:SI 31))]
+  ""
+  "@
+  jal %1
+  jal .+4 ; add 4,r31 ; jmp %1"
+  [(set_attr "length" "4,8")
+   (set_attr "cc" "clobber,clobber")
+   (set_attr "type" "other,other")]
+)
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+;; ----------------------------------------------------------------------
+;; EXTEND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "*zero_extendhisi2_v810"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI
+	(match_operand:HI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]  ;; A lie, but we have to match the expander
+  ""
+  "andi 65535,%1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")])
+
+(define_expand "zero_extendhisi2"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (zero_extend:SI
+		    (match_operand:HI 1 "nonimmediate_operand")))
+	      (clobber (reg:CC CC_REGNUM))])]
+  ""
+  {
+      operands[1] = force_reg (HImode, operands[1]);
+  }
+)
+
+(define_insn "*zero_extendqisi2_v810"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI
+	 (match_operand:QI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))] ;; A lie, but we have to match the expander
+  ""
+  "andi 255,%1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "setcc")])
+
+(define_expand "zero_extendqisi2"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (zero_extend:SI
+		     (match_operand:QI 1 "nonimmediate_operand")))
+	      (clobber (reg:CC CC_REGNUM))])]
+  ""
+  {
+      operands[1] = force_reg (QImode, operands[1]);
+  }
+)
+
+;;- sign extension instructions
+
+(define_insn "*extendhisi_insn"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,m")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "@
+   shl 16,%0 ; sar 16,%0
+   ld.h %1,%0"
+  [(set_attr "length" "4,4")
+   (set_attr "cc" "set_zn,none_0hit")
+   (set_attr "type" "setcc,load")])
+
+(define_expand "extendhisi2"
+  [(parallel [(set (match_dup 2)
+		   (ashift:SI (match_operand:HI 1 "register_operand" "")
+			      (const_int 16)))
+	      (clobber (reg:CC CC_REGNUM))])
+   (parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (ashiftrt:SI (match_dup 2)
+				(const_int 16)))
+	      (clobber (reg:CC CC_REGNUM))])]
+  ""
+  {
+    operands[1] = gen_lowpart (SImode, operands[1]);
+    operands[2] = gen_reg_rtx (SImode);
+  })
+
+(define_insn "*extendqisi_insn"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,m")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "@
+   shl 24,%0 ; sar 24,%0
+   ld.b %1,%0"
+  [(set_attr "length" "4,4")
+   (set_attr "cc" "set_zn,none_0hit")
+   (set_attr "type" "setcc,load")])
+
+(define_expand "extendqisi2"
+  [(parallel [(set (match_dup 2)
+		   (ashift:SI (match_operand:QI 1 "register_operand" "")
+			      (const_int 24)))
+	      (clobber (reg:CC CC_REGNUM))])
+   (parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (ashiftrt:SI (match_dup 2)
+			      (const_int 24)))
+	      (clobber (reg:CC CC_REGNUM))])]
+  ""
+  {
+    operands[1] = gen_lowpart (SImode, operands[1]);
+    operands[2] = gen_reg_rtx (SImode);
+  })
+
+;; ----------------------------------------------------------------------
+;; SHIFTS
+;; ----------------------------------------------------------------------
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+      (ashift:SI
+	(match_operand:SI 1 "register_operand" "0,0")
+	(match_operand:SI 2 "nonmemory_operand" "r,N")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  shl %2,%0
+  shl %2,%0"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "set_zn,set_zn")
+   (set_attr "type" "setcc,setcc")])
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+      (lshiftrt:SI
+	(match_operand:SI 1 "register_operand" "0,0")
+        (match_operand:SI 2 "nonmemory_operand" "r,N")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  shr %2,%0
+  shr %2,%0"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "set_zn,set_zn")
+   (set_attr "type" "setcc,setcc")])
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+      (ashiftrt:SI
+	(match_operand:SI 1 "register_operand" "0,0")
+	(match_operand:SI 2 "nonmemory_operand" "r,N")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  "@
+  sar %2,%0
+  sar %2,%0"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "set_zn,set_zn")
+   (set_attr "type" "setcc,setcc")])
+
+;; ----------------------------------------------------------------------
+;; FIND FIRST BIT INSTRUCTION
+;; ----------------------------------------------------------------------
+
+;; ----------------------------------------------------------------------
+;; PROLOGUE/EPILOGUE
+;; ----------------------------------------------------------------------
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+  {
+    expand_prologue ();
+    DONE;
+  })
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  {
+    expand_epilogue ();
+    DONE;
+  })
+
+(define_insn "return_simple"
+  [(return)]
+  "reload_completed"
+  "jmp [r31]"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+(define_insn "return_internal"
+  [(return)
+   (use (reg:SI 31))]
+  ""
+  "jmp [r31]"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")
+   (set_attr "type" "other")])
+
+;; ----------------------------------------------------------------------
+;; v810 floating-point hardware support
+;; ----------------------------------------------------------------------
+
+(define_insn "addsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(plus:SF (match_operand:SF 1 "register_operand" "%0")
+		 (match_operand:SF 2 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "addf.s %2,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+(define_insn "subsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(minus:SF (match_operand:SF 1 "register_operand" "0")
+		  (match_operand:SF 2 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "subf.s %2,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+(define_insn "mulsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(mult:SF (match_operand:SF 1 "register_operand" "%0")
+		 (match_operand:SF 2 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "mulf.s %2,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+(define_insn "divsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(div:SF (match_operand:SF 1 "register_operand" "0")
+		(match_operand:SF 2 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "divf.s %2,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+;; float -> int
+(define_insn "fix_truncsfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "cvt.sw %1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+;; int -> float
+(define_insn "floatsisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(float:SF (match_operand:SI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_V810"
+  "cvt.ws %1,%0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_zn")
+   (set_attr "type" "float")])
+
+;; ----------------------------------------------------------------------
+;; HELPER INSTRUCTIONS for saving the prologue and epilogue registers
+;; ----------------------------------------------------------------------
+
+;; This pattern will match a frame pointer set, and a stack adjust RTX followed
+;; by any number of push RTXs.  These RTXs will then be turned into a suitable
+;; call to a worker function.
+;; N.B. Heavily modified from V850 for new V810 stack frame, and frame pointer.
+
+(define_insn ""
+ [(match_parallel 0 "pattern_is_ok_for_prologue"
+   [(set (reg:SI 3)
+	 (plus:SI (reg:SI 3) (match_operand:SI 2 "immediate_operand" "i")))
+    (set (reg:SI 2)
+	 (match_operand:SI 1 "register_operand" "r"))
+    (set (mem:SI (plus:SI (reg:SI 3)
+			   (match_operand:SI 3 "immediate_operand" "i")))
+	 (match_operand:SI 4 "register_is_ok_for_epilogue" "r"))])]
+ "TARGET_PROLOG_FUNCTION"
+{
+  return construct_save_jal (operands[0]);
+}
+ [(set_attr "length" "6")
+  (set_attr "cc"     "clobber")])
+
+;; This pattern will match a return RTX followed by any number of pop RTXs
+;; and possible a stack adjustment as well.  These RTXs will be turned into
+;; a suitable call to a worker function.
+;; N.B. Heavily modified from V850 for new V810 stack frame, and frame pointer.
+
+(define_insn ""
+[(match_parallel 0 "pattern_is_ok_for_epilogue"
+   [(return)
+    (set (reg:SI 3)
+	 (plus:SI (reg:SI 2) (match_operand:SI 1 "immediate_operand" "i")))
+    (set (match_operand:SI 2 "register_is_ok_for_epilogue" "=r")
+	 (mem:SI (plus:SI (reg:SI 2)
+			  (match_operand:SI 3 "immediate_operand" "i"))))])]
+ "TARGET_PROLOG_FUNCTION"
+{
+  return construct_restore_jr (operands[0]);
+}
+ [(set_attr "length" "4")
+  (set_attr "cc"     "clobber")])
+
+;; Enter an interrupt function (saving a lot less on the V810 than the V850).
+
+(define_insn "save_interrupt"
+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -4)))
+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 1))]
+  ""
+{
+  output_asm_insn (\"add -4,sp\",    operands);
+  output_asm_insn (\"st.w r1,0[sp]\", operands);
+  return \"\";
+}
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+;; Leave an interrupt function (loading a lot less on the V810 than the V850).
+
+(define_insn "return_interrupt"
+  [(return)
+   (set (reg:SI 3)  (plus:SI (reg:SI 3) (const_int 4)))
+   (set (reg:SI 1)  (mem:SI (plus:SI (reg:SI 3) (const_int 0))))]
+  ""
+{
+  output_asm_insn (\"ld.w 0[sp],r1\",  operands);
+  output_asm_insn (\"add 4,sp\",      operands);
+  output_asm_insn (\"reti\",           operands);
+  return \"\";
+}
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+;; ----------------------------------------------------------------------
+;; PEEPHOLE OPTIMIZATIONS
+;; ----------------------------------------------------------------------
+
+;; JCB 2022-02-18 (Thanks to the author of arm/arm.md!)
+;;
+;; GCC converts *some* frame-pointer address references into ...
+;;   ADDI $xxxx, fp, rDEST
+;;
+;; GCC converts *other* frame-pointer address references into ...
+;;   MOVEA $xxxx, r0, rDEST
+;;   ADD fp, rDEST
+;;
+;; These two peephole optimizations turn them both into ...
+;;   MOVEA lo($xxxx), fp, rDEST
+;;
+;; ... which avoids clobbering CC_REGNUM!
+;;
+;; Alternatively, we could just use this to shorten the 1st into ...
+;;   ADDI $xxxx, fp, rDEST
+;;
+;;   [(parallel [(set (match_dup 0)
+;; 		   (plus:SI (reg:SI FP_REGNUM) (match_dup 1)))
+;; 	      (clobber (reg:CC CC_REGNUM))])]
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (plus:SI (reg:SI FP_REGNUM) (match_operand:SI 1 "const_int_operand" "")))
+	      (clobber (reg:CC CC_REGNUM))])]
+  "CONST_OK_FOR_K (INTVAL (operands[1]))"
+  [(set (match_dup 0) (lo_sum:SI (reg:SI FP_REGNUM) (match_dup 1)))]
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))
+   (parallel [(set (match_dup 0)
+		   (plus:SI (match_dup 0) (reg:SI FP_REGNUM)))
+	      (clobber (reg:CC CC_REGNUM))])]
+  "CONST_OK_FOR_K (INTVAL (operands[1]))"
+  [(set (match_dup 0) (lo_sum:SI (reg:SI FP_REGNUM) (match_dup 1)))]
+  ""
+)
diff -Naur gcc-4.9.4-pure/gcc/config/v810/v810.opt gcc-4.9.4/gcc/config/v810/v810.opt
--- gcc-4.9.4-pure/gcc/config/v810/v810.opt	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/gcc/config/v810/v810.opt	2022-02-27 14:57:28.841571900 -0500
@@ -0,0 +1,63 @@
+; Options for the NEC V810 port of the compiler.
+
+; Copyright (C) 2005-2014 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+HeaderInclude
+config/v810/v810-opts.h
+
+Variable
+int small_memory_max[(int)SMALL_MEMORY_max] = { 0, 0, 0 }
+
+mbig-switch
+Target Report Mask(BIG_SWITCH)
+Use 4 byte entries in switch tables
+
+mdebug
+Target Report Mask(DEBUG)
+Enable backend debugging
+
+mprolog-function
+Target Report Mask(PROLOG_FUNCTION)
+Use stubs for function prologues
+
+msda=
+Target RejectNegative Joined UInteger
+Set the max size of data eligible for the SDA area
+
+msda-
+Target RejectNegative Joined Undocumented Alias(msda=)
+
+mjump-tables-in-data-section
+Target Report Mask(JUMP_TABLES_IN_DATA_SECTION)
+Put jump tables for switch statements into the .data section rather than the .code section
+
+mv810
+Target Report RejectNegative Mask(V810)
+Compile for the v810 processor
+
+mzda=
+Target RejectNegative Joined UInteger
+Set the max size of data eligible for the ZDA area
+
+mzda-
+Target RejectNegative Joined Undocumented Alias(mzda=)
+
+mrelax
+Target Report Mask(RELAX)
+Enable relaxing in the assembler
diff -Naur gcc-4.9.4-pure/gcc/config.gcc gcc-4.9.4/gcc/config.gcc
--- gcc-4.9.4-pure/gcc/config.gcc	2016-03-14 06:03:12.000000000 -0400
+++ gcc-4.9.4/gcc/config.gcc	2022-02-27 14:57:28.850572400 -0500
@@ -479,6 +479,9 @@
 	extra_options="${extra_options} fused-madd.opt"
 	extra_objs="${extra_objs} sh_treg_combine.o sh-mem.o sh_optimize_sett_clrt.o"
 	;;
+v810*-*-*)
+	cpu_type=v810
+	;;
 v850*-*-*)
 	cpu_type=v850
 	;;
@@ -2800,6 +2803,32 @@
 	cxx_target_objs="${cxx_target_objs} tilepro-c.o"
 	extra_headers="feedback.h"
 	;;
+v810-*-rtems*)
+	target_cpu_default="TARGET_CPU_generic"
+	tm_file="dbxelf.h elfos.h v810/v810.h"
+	tm_file="${tm_file} rtems.h v810/rtems.h newlib-stdint.h"
+	tmake_file="${tmake_file} v810/t-v810"
+	tmake_file="${tmake_file} t-rtems v810/t-rtems"
+	use_collect2=no
+	c_target_objs="v810-c.o"
+	cxx_target_objs="v810-c.o"
+	;;
+v810*-*-*)
+	case ${target} in
+	v810-*-*)
+		target_cpu_default="TARGET_CPU_generic"
+		;;
+	esac
+	tm_file="dbxelf.h elfos.h newlib-stdint.h v810/v810.h"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v810-c.o"
+	cxx_target_objs="v810-c.o"
+	use_gcc_stdint=wrap
+	;;
 v850-*-rtems*)
 	target_cpu_default="TARGET_CPU_generic"
 	tm_file="dbxelf.h elfos.h v850/v850.h"
diff -Naur gcc-4.9.4-pure/libgcc/config/v810/lib1funcs.S gcc-4.9.4/libgcc/config/v810/lib1funcs.S
--- gcc-4.9.4-pure/libgcc/config/v810/lib1funcs.S	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/libgcc/config/v810/lib1funcs.S	2022-02-27 14:57:28.860573000 -0500
@@ -0,0 +1,514 @@
+/* libgcc routines for NEC V810.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3, or (at your option) any
+   later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* JCB - Modified to save FP at bottom of the saved-registers, followed by LP.
+
+   Saved-Registers are pushed in the opposite order to which they're
+   allocated by the compiler.
+   So the 1st-allocated saved-register is at the lowest address.
+   HARD_FRAME_POINTER_REGNUM is set to the 1st-allocatable saved-register
+   so that it always gets saved at the lowest address.
+   V810: Allocate space for the LP register if any registers are saved.
+
+   *****************************
+
+   GCC 1999-ABI V850 STACK FRAME (stack grows downwards)
+
+   CALLER    incoming-arg? (to CALLEE)
+             ...
+             incoming-arg5
+             incoming-arg4
+   ap->      16-bytes-reserved arg0..arg3
+
+   CALLEE    saved-lp
+             saved-...
+             saved-r27
+             saved-r28
+   fp->      saved-fp
+             local-variables
+             outgoing-arg? (to next CALLEE)
+             ...
+             outgoing-arg5
+             outgoing-arg4
+   sp->      16-bytes-reserved for arg0..arg3
+
+   *****************************
+
+   GCC 2010-ABI V850 STACK FRAME (stack grows downwards)
+
+   CALLER    incoming-arg? (to CALLEE)
+             ...
+             incoming-arg5
+   ap->      incoming-arg4
+
+   CALLEE    saved-lp
+             saved-...
+             saved-r27
+             saved-r28
+   fp->      saved-fp
+             local-variables
+             outgoing-arg? (to next CALLEE)
+             ...
+             outgoing-arg5
+   sp->      outgoing-arg4
+
+   *****************************
+
+   GCC 2016-ABI V810 STACK FRAME (stack grows downwards)
+
+   This frame layout allows for easy in-app stack tracing!
+
+   CALLER    incoming-arg? (to CALLEE)
+             ...
+             incoming-arg5
+   ap->      incoming-arg4
+
+   CALLEE    saved-...
+             saved-r28
+             saved-r29
+             saved-lp
+   fp->      saved-fp
+             local-variables
+             outgoing-arg? (to next CALLEE)
+             ...
+             outgoing-arg5
+   sp->      outgoing-arg4
+*/
+
+/* GCC generates these as inline code on the V810.
+#ifdef L_mulsi3
+#ifdef L_udivsi3
+#ifdef L_divsi3
+#ifdef L_umodsi3
+#ifdef L_modsi3
+*/
+
+/*
+ * Prolog functions with stack-overflow detection.
+ *
+ * N.B. Not currently used ... but maybe, someday.
+ */
+
+#ifdef          L_save_warn_fp
+
+                .section .sdata,"aw"
+                .align 2
+
+                .global _sda_frame_count
+                .type   _sp_warn_addr, @object
+                .size   _sp_warn_addr, 4
+_sp_warn_addr:  .word   _end + 1024
+
+                .global _sda_frame_count
+                .type   _sp_warn_func, @object
+                .size   _sp_warn_func, 4
+_sp_warn_func:  .word   _debugstack
+
+                .text
+
+                .globl  __save_warn_r20_fp
+                .globl  __save_warn_r21_fp
+                .globl  __save_warn_r22_fp
+                .globl  __save_warn_r23_fp
+                .globl  __save_warn_r24_fp
+                .globl  __save_warn_r25_fp
+                .globl  __save_warn_r26_fp
+                .globl  __save_warn_r27_fp
+                .globl  __save_warn_r28_fp
+                .globl  __save_warn_r29_fp
+                .globl  __save_warn_r31_fp
+
+                .type   __save_warn_r20_fp,@function
+                .type   __save_warn_r21_fp,@function
+                .type   __save_warn_r22_fp,@function
+                .type   __save_warn_r23_fp,@function
+                .type   __save_warn_r24_fp,@function
+                .type   __save_warn_r25_fp,@function
+                .type   __save_warn_r26_fp,@function
+                .type   __save_warn_r27_fp,@function
+                .type   __save_warn_r28_fp,@function
+                .type   __save_warn_r29_fp,@function
+                .type   __save_warn_r31_fp,@function
+
+                .globl  __push_warn_r20_fp
+                .globl  __push_warn_r21_fp
+                .globl  __push_warn_r22_fp
+                .globl  __push_warn_r23_fp
+                .globl  __push_warn_r24_fp
+                .globl  __push_warn_r25_fp
+                .globl  __push_warn_r26_fp
+                .globl  __push_warn_r27_fp
+                .globl  __push_warn_r28_fp
+                .globl  __push_warn_r29_fp
+                .globl  __push_warn_r31_fp
+
+                .type   __push_warn_r20_fp,@function
+                .type   __push_warn_r21_fp,@function
+                .type   __push_warn_r22_fp,@function
+                .type   __push_warn_r23_fp,@function
+                .type   __push_warn_r24_fp,@function
+                .type   __push_warn_r25_fp,@function
+                .type   __push_warn_r26_fp,@function
+                .type   __push_warn_r27_fp,@function
+                .type   __push_warn_r28_fp,@function
+                .type   __push_warn_r29_fp,@function
+                .type   __push_warn_r31_fp,@function
+
+                .align  2
+__save_warn_r20_fp:
+                addi    -0x30,sp,sp
+                br      __push_warn_r20_fp
+__save_warn_r21_fp:
+                addi    -0x2c,sp,sp
+                br      __push_warn_r21_fp
+__save_warn_r22_fp:
+                addi    -0x28,sp,sp
+                br      __push_warn_r22_fp
+__save_warn_r23_fp:
+                addi    -0x24,sp,sp
+                br      __push_warn_r23_fp
+__save_warn_r24_fp:
+                addi    -0x20,sp,sp
+                br      __push_warn_r24_fp
+__save_warn_r25_fp:
+                addi    -0x1c,sp,sp
+                br      __push_warn_r25_fp
+__save_warn_r26_fp:
+                addi    -0x18,sp,sp
+                br      __push_warn_r26_fp
+__save_warn_r27_fp:
+                addi    -0x14,sp,sp
+                br      __push_warn_r27_fp
+
+                .align  2
+__save_warn_r28_fp:
+                add     -0x10,sp
+                br      __push_warn_r28_fp
+__save_warn_r29_fp:
+                add     -0x0c,sp
+                br      __push_warn_r29_fp
+__save_warn_r31_fp:
+                add     -0x08,sp
+                br      __push_warn_r31_fp
+
+                .align  2
+__push_warn_r20_fp:
+                st.w    r20,0x2c[sp]
+__push_warn_r21_fp:
+                st.w    r21,0x28[sp]
+__push_warn_r22_fp:
+                st.w    r22,0x24[sp]
+__push_warn_r23_fp:
+                st.w    r23,0x20[sp]
+__push_warn_r24_fp:
+                st.w    r24,0x1c[sp]
+__push_warn_r25_fp:
+                st.w    r25,0x18[sp]
+__push_warn_r26_fp:
+                st.w    r26,0x14[sp]
+__push_warn_r27_fp:
+                st.w    r27,0x10[sp]
+__push_warn_r28_fp:
+                st.w    r28,0x0c[sp]
+__push_warn_r29_fp:
+                st.w    r29,0x08[sp]
+__push_warn_r31_fp:
+                st.w    fp,0x00[sp]
+                mov     sp,fp
+                ld.w    sdaoff(_sp_warn_addr)[gp],r10
+                cmp     r10,sp
+                st.w    r1,0x04[sp]
+                bge     __warn_overflow
+                jmp     [lp]
+__warn_overflow:ld.w    sdaoff(_sp_warn_func)[gp],r10
+                jmp     [r10]
+
+#endif /* L_save_warn_fp */
+
+/*
+ * Prolog functions for saving memory.
+ */
+
+#ifdef          L_save_fp
+                .text
+
+                .globl  __save_r20_fp
+                .globl  __save_r21_fp
+                .globl  __save_r22_fp
+                .globl  __save_r23_fp
+                .globl  __save_r24_fp
+                .globl  __save_r25_fp
+                .globl  __save_r26_fp
+                .globl  __save_r27_fp
+                .globl  __save_r28_fp
+                .globl  __save_r29_fp
+                .globl  __save_r31_fp
+
+                .type   __save_r20_fp,@function
+                .type   __save_r21_fp,@function
+                .type   __save_r22_fp,@function
+                .type   __save_r23_fp,@function
+                .type   __save_r24_fp,@function
+                .type   __save_r25_fp,@function
+                .type   __save_r26_fp,@function
+                .type   __save_r27_fp,@function
+                .type   __save_r28_fp,@function
+                .type   __save_r29_fp,@function
+                .type   __save_r31_fp,@function
+
+                .globl  __push_r20_fp
+                .globl  __push_r21_fp
+                .globl  __push_r22_fp
+                .globl  __push_r23_fp
+                .globl  __push_r24_fp
+                .globl  __push_r25_fp
+                .globl  __push_r26_fp
+                .globl  __push_r27_fp
+                .globl  __push_r28_fp
+                .globl  __push_r29_fp
+                .globl  __push_r31_fp
+
+                .type   __push_r20_fp,@function
+                .type   __push_r21_fp,@function
+                .type   __push_r22_fp,@function
+                .type   __push_r23_fp,@function
+                .type   __push_r24_fp,@function
+                .type   __push_r25_fp,@function
+                .type   __push_r26_fp,@function
+                .type   __push_r27_fp,@function
+                .type   __push_r28_fp,@function
+                .type   __push_r29_fp,@function
+                .type   __push_r31_fp,@function
+
+                .align  2
+__save_r20_fp:  addi    -0x30,sp,sp
+                br      __push_r20_fp
+__save_r21_fp:  addi    -0x2c,sp,sp
+                br      __push_r21_fp
+__save_r22_fp:  addi    -0x28,sp,sp
+                br      __push_r22_fp
+__save_r23_fp:  addi    -0x24,sp,sp
+                br      __push_r23_fp
+__save_r24_fp:  addi    -0x20,sp,sp
+                br      __push_r24_fp
+__save_r25_fp:  addi    -0x1c,sp,sp
+                br      __push_r25_fp
+__save_r26_fp:  addi    -0x18,sp,sp
+                br      __push_r26_fp
+__save_r27_fp:  addi    -0x14,sp,sp
+                br      __push_r27_fp
+
+                .align  2
+__save_r28_fp:  add     -0x10,sp
+                br      __push_r28_fp
+__save_r29_fp:  add     -0x0c,sp
+                br      __push_r29_fp
+__save_r31_fp:  add     -0x08,sp
+                br      __push_r31_fp
+
+                .align  2
+__push_r20_fp:  st.w    r20,0x2c[sp]
+__push_r21_fp:  st.w    r21,0x28[sp]
+__push_r22_fp:  st.w    r22,0x24[sp]
+__push_r23_fp:  st.w    r23,0x20[sp]
+__push_r24_fp:  st.w    r24,0x1c[sp]
+__push_r25_fp:  st.w    r25,0x18[sp]
+__push_r26_fp:  st.w    r26,0x14[sp]
+__push_r27_fp:  st.w    r27,0x10[sp]
+__push_r28_fp:  st.w    r28,0x0c[sp]
+__push_r29_fp:  st.w    r29,0x08[sp]
+__push_r31_fp:  st.w    r1,0x04[sp]
+                st.w    fp,0x00[sp]
+                mov     sp,fp
+                jmp     [lp]
+
+#endif /* L_save_fp */
+
+/*
+ *
+ */
+
+#ifdef          L_load_fp
+                .text
+                .globl  __load_r20_fp
+                .globl  __load_r21_fp
+                .globl  __load_r22_fp
+                .globl  __load_r23_fp
+                .globl  __load_r24_fp
+                .globl  __load_r25_fp
+                .globl  __load_r26_fp
+                .globl  __load_r27_fp
+                .globl  __load_r28_fp
+                .globl  __load_r29_fp
+                .globl  __load_r31_fp
+
+                .type   __load_r20_fp,@function
+                .type   __load_r21_fp,@function
+                .type   __load_r22_fp,@function
+                .type   __load_r23_fp,@function
+                .type   __load_r24_fp,@function
+                .type   __load_r25_fp,@function
+                .type   __load_r26_fp,@function
+                .type   __load_r27_fp,@function
+                .type   __load_r28_fp,@function
+                .type   __load_r29_fp,@function
+                .type   __load_r31_fp,@function
+
+                .globl  __pop_r20_fp
+                .globl  __pop_r21_fp
+                .globl  __pop_r22_fp
+                .globl  __pop_r23_fp
+                .globl  __pop_r24_fp
+                .globl  __pop_r25_fp
+                .globl  __pop_r26_fp
+                .globl  __pop_r27_fp
+                .globl  __pop_r28_fp
+                .globl  __pop_r29_fp
+                .globl  __pop_r31_fp
+
+                .type   __pop_r20_fp,@function
+                .type   __pop_r21_fp,@function
+                .type   __pop_r22_fp,@function
+                .type   __pop_r23_fp,@function
+                .type   __pop_r24_fp,@function
+                .type   __pop_r25_fp,@function
+                .type   __pop_r26_fp,@function
+                .type   __pop_r27_fp,@function
+                .type   __pop_r28_fp,@function
+                .type   __pop_r29_fp,@function
+                .type   __pop_r31_fp,@function
+
+                .align  2
+__load_r20_fp:  addi    0x30,fp,r1
+                br      __pop_r20_fp
+__load_r21_fp:  addi    0x2c,fp,r1
+                br      __pop_r21_fp
+__load_r22_fp:  addi    0x28,fp,r1
+                br      __pop_r22_fp
+__load_r23_fp:  addi    0x24,fp,r1
+                br      __pop_r23_fp
+__load_r24_fp:  addi    0x20,fp,r1
+                br      __pop_r24_fp
+__load_r25_fp:  addi    0x1c,fp,r1
+                br      __pop_r25_fp
+__load_r26_fp:  addi    0x18,fp,r1
+                br      __pop_r26_fp
+__load_r27_fp:  addi    0x14,fp,r1
+                br      __pop_r27_fp
+__load_r28_fp:  addi    0x10,fp,r1
+                br      __pop_r28_fp
+__load_r29_fp:  addi    0x0c,fp,r1
+                br      __pop_r29_fp
+__load_r31_fp:  addi    0x08,fp,r1
+                br      __pop_r31_fp
+
+                .align  2
+__pop_r20_fp:   ld.w    0x2c[fp],r20
+__pop_r21_fp:   ld.w    0x28[fp],r21
+__pop_r22_fp:   ld.w    0x24[fp],r22
+__pop_r23_fp:   ld.w    0x20[fp],r23
+__pop_r24_fp:   ld.w    0x1c[fp],r24
+__pop_r25_fp:   ld.w    0x18[fp],r25
+__pop_r26_fp:   ld.w    0x14[fp],r26
+__pop_r27_fp:   ld.w    0x10[fp],r27
+__pop_r28_fp:   ld.w    0x0c[fp],r28
+__pop_r29_fp:   ld.w    0x08[fp],r29
+__pop_r31_fp:   ld.w    0x04[fp],lp
+                ld.w    0x00[fp],fp
+                mov     r1,sp
+                jmp     [lp]
+
+#endif /* L_load_fp */
+
+/*  libgcc2 routines for NEC V810.  */
+/*  Double Integer Arithmetical Operation.  */
+
+#ifdef L_negdi2
+                .text
+                .global ___negdi2
+                .type   ___negdi2, @function
+___negdi2:      not     r6, r10
+                add     1,  r10
+                setf    l,  r6
+                not     r7, r11
+                add     r6, r11
+                jmp     [lp]
+                .size ___negdi2,.-___negdi2
+#endif
+
+#ifdef L_cmpdi2
+                .text
+                .global ___cmpdi2
+                .type   ___cmpdi2,@function
+        # Signed comparison bitween each high word.
+___cmpdi2:      cmp     r9, r7
+                be      .L_cmpdi_cmp_low
+                setf    ge, r10
+                setf    gt, r6
+                add     r6, r10
+                jmp     [lp]
+        # Unsigned comparison bitween each low word.
+.L_cmpdi_cmp_low:
+                cmp     r8, r6
+                setf    nl, r10
+                setf    h,  r6
+                add     r6, r10
+                jmp     [lp]    
+                .size ___cmpdi2, . - ___cmpdi2  
+#endif
+
+#ifdef L_ucmpdi2
+                .text
+                .global ___ucmpdi2
+                .type   ___ucmpdi2,@function
+___ucmpdi2:     cmp     r9, r7  # Check if each high word are same.
+                be      .L_ucmpdi_check_psw
+                cmp     r8, r6  # Compare the word.
+.L_ucmpdi_check_psw:
+                setf    nl, r10 # 
+                setf    h,  r6  # 
+                add     r6, r10 # Add the result of comparison NL and comparison H.
+                jmp     [lp]    
+                .size ___ucmpdi2, . - ___ucmpdi2
+#endif
+
+#ifdef L_muldi3
+                .text
+                .global ___muldi3
+                .type   ___muldi3,@function
+___muldi3:
+                /*  (Ahi << 32 + Alo) * (Bhi << 32 + Blo) */
+                /*   r7           r6      r9         r8   */
+                mov  r30,  r1
+                mov  r8,  r10
+                mulu r7,   r8  /* Ahi * Blo */
+                mulu r6,   r9  /* Alo * Bhi */
+                mulu r6,  r10  /* Alo * Blo */
+                mov  r30, r11
+                add  r8,  r11
+                add  r9,  r11
+                mov  r1,  r30
+                jmp  [r31]
+                .size ___muldi3, . - ___muldi3
+#endif
diff -Naur gcc-4.9.4-pure/libgcc/config/v810/t-v810 gcc-4.9.4/libgcc/config/v810/t-v810
--- gcc-4.9.4-pure/libgcc/config/v810/t-v810	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.9.4/libgcc/config/v810/t-v810	2022-02-27 14:57:28.868573400 -0500
@@ -0,0 +1,11 @@
+LIB1ASMSRC = v810/lib1funcs.S
+LIB1ASMFUNCS	= \
+		  _save_warn_fp \
+		  _save_fp \
+		  _load_fp \
+		  _negdi2 \
+		  _cmpdi2 \
+		  _ucmpdi2 \
+		  _muldi3
+
+HOST_LIBGCC2_CFLAGS += -O2 -fomit-frame-pointer -mno-prolog-function
diff -Naur gcc-4.9.4-pure/libgcc/config.host gcc-4.9.4/libgcc/config.host
--- gcc-4.9.4-pure/libgcc/config.host	2016-05-17 02:22:28.000000000 -0400
+++ gcc-4.9.4/libgcc/config.host	2022-02-27 14:57:28.871573600 -0500
@@ -192,6 +192,9 @@
 tilepro*-*-*)
 	cpu_type=tilepro
 	;;
+v810*-*-*)
+	cpu_type=v810
+	;;
 v850*-*-*)
 	cpu_type=v850
 	;;
@@ -1192,6 +1195,9 @@
 	tmake_file="${tmake_file} tilepro/t-crtstuff t-softfp-sfdf t-softfp tilepro/t-tilepro"
 	md_unwind_header=tilepro/linux-unwind.h
         ;;
+v810*-*-*)
+	tmake_file="${tmake_file} v810/t-v810 t-fpbit"
+	;;
 v850*-*-*)
 	tmake_file="${tmake_file} v850/t-v850 t-fdpbit"
 	;;
diff -Naur gcc-4.9.4-pure/libgcc/libgcc2.c gcc-4.9.4/libgcc/libgcc2.c
--- gcc-4.9.4-pure/libgcc/libgcc2.c	2022-02-27 14:51:03.232536400 -0500
+++ gcc-4.9.4/libgcc/libgcc2.c	2022-02-27 14:57:28.876573900 -0500
@@ -1466,7 +1466,6 @@
 	 format, it would be significantly faster.  */
 
       UWtype shift = 0, counter;
-      SFtype msb;
 
       a /= Wtype_MAXp1_F;
       for (counter = W_TYPE_SIZE / 2; counter != 0; counter >>= 1)
